// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: hotel_reservation.proto
// Protobuf C++ Version: 5.27.0-dev

#ifndef GOOGLE_PROTOBUF_INCLUDED_hotel_5freservation_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_hotel_5freservation_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 5027000
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_hotel_5freservation_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_hotel_5freservation_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_hotel_5freservation_2eproto;
namespace hotelreservation {
class Address;
struct AddressDefaultTypeInternal;
extern AddressDefaultTypeInternal _Address_default_instance_;
class CheckUserRequest;
struct CheckUserRequestDefaultTypeInternal;
extern CheckUserRequestDefaultTypeInternal _CheckUserRequest_default_instance_;
class CheckUserResponse;
struct CheckUserResponseDefaultTypeInternal;
extern CheckUserResponseDefaultTypeInternal _CheckUserResponse_default_instance_;
class GetProfilesRequest;
struct GetProfilesRequestDefaultTypeInternal;
extern GetProfilesRequestDefaultTypeInternal _GetProfilesRequest_default_instance_;
class GetProfilesResponse;
struct GetProfilesResponseDefaultTypeInternal;
extern GetProfilesResponseDefaultTypeInternal _GetProfilesResponse_default_instance_;
class GetRatesRequest;
struct GetRatesRequestDefaultTypeInternal;
extern GetRatesRequestDefaultTypeInternal _GetRatesRequest_default_instance_;
class GetRatesResponse;
struct GetRatesResponseDefaultTypeInternal;
extern GetRatesResponseDefaultTypeInternal _GetRatesResponse_default_instance_;
class Hotel;
struct HotelDefaultTypeInternal;
extern HotelDefaultTypeInternal _Hotel_default_instance_;
class HotelNumber;
struct HotelNumberDefaultTypeInternal;
extern HotelNumberDefaultTypeInternal _HotelNumber_default_instance_;
class HotelProfile;
struct HotelProfileDefaultTypeInternal;
extern HotelProfileDefaultTypeInternal _HotelProfile_default_instance_;
class NearbyRequest;
struct NearbyRequestDefaultTypeInternal;
extern NearbyRequestDefaultTypeInternal _NearbyRequest_default_instance_;
class NearbyResponse;
struct NearbyResponseDefaultTypeInternal;
extern NearbyResponseDefaultTypeInternal _NearbyResponse_default_instance_;
class Point;
struct PointDefaultTypeInternal;
extern PointDefaultTypeInternal _Point_default_instance_;
class RatePlan;
struct RatePlanDefaultTypeInternal;
extern RatePlanDefaultTypeInternal _RatePlan_default_instance_;
class RecommendRequest;
struct RecommendRequestDefaultTypeInternal;
extern RecommendRequestDefaultTypeInternal _RecommendRequest_default_instance_;
class RecommendResponse;
struct RecommendResponseDefaultTypeInternal;
extern RecommendResponseDefaultTypeInternal _RecommendResponse_default_instance_;
class Reservation;
struct ReservationDefaultTypeInternal;
extern ReservationDefaultTypeInternal _Reservation_default_instance_;
class ReservationRequest;
struct ReservationRequestDefaultTypeInternal;
extern ReservationRequestDefaultTypeInternal _ReservationRequest_default_instance_;
class ReservationResponse;
struct ReservationResponseDefaultTypeInternal;
extern ReservationResponseDefaultTypeInternal _ReservationResponse_default_instance_;
class RoomType;
struct RoomTypeDefaultTypeInternal;
extern RoomTypeDefaultTypeInternal _RoomType_default_instance_;
class SearchRequest;
struct SearchRequestDefaultTypeInternal;
extern SearchRequestDefaultTypeInternal _SearchRequest_default_instance_;
class SearchResponse;
struct SearchResponseDefaultTypeInternal;
extern SearchResponseDefaultTypeInternal _SearchResponse_default_instance_;
class User;
struct UserDefaultTypeInternal;
extern UserDefaultTypeInternal _User_default_instance_;
class UserRequest;
struct UserRequestDefaultTypeInternal;
extern UserRequestDefaultTypeInternal _UserRequest_default_instance_;
class UserResponse;
struct UserResponseDefaultTypeInternal;
extern UserResponseDefaultTypeInternal _UserResponse_default_instance_;
}  // namespace hotelreservation
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace hotelreservation {

// ===================================================================


// -------------------------------------------------------------------

class UserResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:hotelreservation.UserResponse) */ {
 public:
  inline UserResponse() : UserResponse(nullptr) {}
  ~UserResponse() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR UserResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline UserResponse(const UserResponse& from) : UserResponse(nullptr, from) {}
  inline UserResponse(UserResponse&& from) noexcept
      : UserResponse(nullptr, std::move(from)) {}
  inline UserResponse& operator=(const UserResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserResponse& operator=(UserResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserResponse* internal_default_instance() {
    return reinterpret_cast<const UserResponse*>(
        &_UserResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 14;
  friend void swap(UserResponse& a, UserResponse& b) { a.Swap(&b); }
  inline void Swap(UserResponse* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<UserResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UserResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const UserResponse& from) { UserResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(UserResponse* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "hotelreservation.UserResponse"; }

 protected:
  explicit UserResponse(::google::protobuf::Arena* arena);
  UserResponse(::google::protobuf::Arena* arena, const UserResponse& from);
  UserResponse(::google::protobuf::Arena* arena, UserResponse&& from) noexcept
      : UserResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // schemas for IAA/DSA ---------------------------------------------
  void generate_schema(std::vector<std::tuple<uint8_t*, size_t>> &schema) {
      schema.push_back(std::make_tuple(reinterpret_cast<uint8_t*>(const_cast<char*>(message().c_str())), message().size()));
  }
  void generate_seperated_schema(std::vector<uint8_t*> &ptrs_list, std::vector<size_t> &sizes_list) {
      ptrs_list.push_back(nullptr);
      sizes_list.push_back(0);
      ptrs_list.push_back(reinterpret_cast<uint8_t*>(const_cast<char*>(message().c_str())));
      sizes_list.push_back(message().size());
  }
  void generate_scatter_ptrs(std::vector<uint8_t*> &ptrs) {
      ptrs.push_back(nullptr);
      ptrs.push_back(reinterpret_cast<uint8_t*>(const_cast<char*>(message().c_str())));
  }
  void generate_scatter_sizes(std::vector<size_t> &sizes) {
      sizes.push_back(0);
      sizes.push_back(message().size());
  }
  size_t generate_scatter_ptrs_and_allocate_from_sizes(std::vector<uint8_t*> &ptrs, std::vector<size_t> &sizes, size_t idx = 0) {
      idx++;
      // only primitive field pointers
      ptrs.push_back(nullptr);
      // non-primitive field pointers + allocation
      // allocate
      {
      std::string tmp_str(sizes[idx++], 'x');  // Preallocate needed size
      set_message(std::move(tmp_str));
      }
      //std::string tmp_str1(sizes[idx++], 'x');  // Preallocate needed size
      //set_message(std::move(tmp_str1));
      // store pointer in the pointers list
      ptrs.push_back(reinterpret_cast<uint8_t*>(const_cast<char*>(message().c_str())));
      return idx;
  }
  size_t allocate_from_sizes(std::vector<size_t> &sizes, size_t idx = 0) {
      idx++;
      {
        std::string tmp_str(sizes[idx++], 'x');  // Preallocate needed size
        set_message(std::move(tmp_str));
      }
      return idx;
  }

  // accessors -------------------------------------------------------
  enum : int {
    kMessageFieldNumber = 1,
  };
  // string message = 1;
  void clear_message() ;
  const std::string& message() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_message(Arg_&& arg, Args_... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* value);

  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(
      const std::string& value);
  std::string* _internal_mutable_message();

  public:
  // @@protoc_insertion_point(class_scope:hotelreservation.UserResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      45, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_UserResponse_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr message_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_hotel_5freservation_2eproto;
};
// -------------------------------------------------------------------

class UserRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:hotelreservation.UserRequest) */ {
 public:
  inline UserRequest() : UserRequest(nullptr) {}
  ~UserRequest() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR UserRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline UserRequest(const UserRequest& from) : UserRequest(nullptr, from) {}
  inline UserRequest(UserRequest&& from) noexcept
      : UserRequest(nullptr, std::move(from)) {}
  inline UserRequest& operator=(const UserRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserRequest& operator=(UserRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserRequest* internal_default_instance() {
    return reinterpret_cast<const UserRequest*>(
        &_UserRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 13;
  friend void swap(UserRequest& a, UserRequest& b) { a.Swap(&b); }
  inline void Swap(UserRequest* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<UserRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UserRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const UserRequest& from) { UserRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(UserRequest* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "hotelreservation.UserRequest"; }

 protected:
  explicit UserRequest(::google::protobuf::Arena* arena);
  UserRequest(::google::protobuf::Arena* arena, const UserRequest& from);
  UserRequest(::google::protobuf::Arena* arena, UserRequest&& from) noexcept
      : UserRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // schemas for IAA/DSA ---------------------------------------------
  void generate_schema(std::vector<std::tuple<uint8_t*, size_t>> &schema) {
      schema.push_back(std::make_tuple(reinterpret_cast<uint8_t*>(const_cast<char*>(username().c_str())), username().size()));
      schema.push_back(std::make_tuple(reinterpret_cast<uint8_t*>(const_cast<char*>(password().c_str())), password().size()));
  }
  void generate_seperated_schema(std::vector<uint8_t*> &ptrs_list, std::vector<size_t> &sizes_list) {
      ptrs_list.push_back(nullptr);
      sizes_list.push_back(0);
      ptrs_list.push_back(reinterpret_cast<uint8_t*>(const_cast<char*>(username().c_str())));
      sizes_list.push_back(username().size());
      ptrs_list.push_back(reinterpret_cast<uint8_t*>(const_cast<char*>(password().c_str())));
      sizes_list.push_back(password().size());
  }
  void generate_scatter_ptrs(std::vector<uint8_t*> &ptrs) {
      ptrs.push_back(nullptr);
      ptrs.push_back(reinterpret_cast<uint8_t*>(const_cast<char*>(username().c_str())));
      ptrs.push_back(reinterpret_cast<uint8_t*>(const_cast<char*>(password().c_str())));
  }
  void generate_scatter_sizes(std::vector<size_t> &sizes) {
      sizes.push_back(0);
      sizes.push_back(username().size());
      sizes.push_back(password().size());
  }
  size_t generate_scatter_ptrs_and_allocate_from_sizes(std::vector<uint8_t*> &ptrs, std::vector<size_t> &sizes, size_t idx = 0) {
      idx++;
      // only primitive field pointers
      ptrs.push_back(nullptr);
      // non-primitive field pointers + allocation
      // allocate
      {
      std::string tmp_str(sizes[idx++], 'x');  // Preallocate needed size
      set_username(std::move(tmp_str));
      }
      //std::string tmp_str1(sizes[idx++], 'x');  // Preallocate needed size
      //set_username(std::move(tmp_str1));
      // store pointer in the pointers list
      ptrs.push_back(reinterpret_cast<uint8_t*>(const_cast<char*>(username().c_str())));
      // allocate
      {
      std::string tmp_str(sizes[idx++], 'x');  // Preallocate needed size
      set_password(std::move(tmp_str));
      }
      //std::string tmp_str2(sizes[idx++], 'x');  // Preallocate needed size
      //set_password(std::move(tmp_str2));
      // store pointer in the pointers list
      ptrs.push_back(reinterpret_cast<uint8_t*>(const_cast<char*>(password().c_str())));
      return idx;
  }
  size_t allocate_from_sizes(std::vector<size_t> &sizes, size_t idx = 0) {
      idx++;
      {
        std::string tmp_str(sizes[idx++], 'x');  // Preallocate needed size
        set_username(std::move(tmp_str));
      }
      {
        std::string tmp_str(sizes[idx++], 'x');  // Preallocate needed size
        set_password(std::move(tmp_str));
      }
      return idx;
  }

  // accessors -------------------------------------------------------
  enum : int {
    kUsernameFieldNumber = 1,
    kPasswordFieldNumber = 2,
  };
  // string username = 1;
  void clear_username() ;
  const std::string& username() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_username(Arg_&& arg, Args_... args);
  std::string* mutable_username();
  PROTOBUF_NODISCARD std::string* release_username();
  void set_allocated_username(std::string* value);

  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(
      const std::string& value);
  std::string* _internal_mutable_username();

  public:
  // string password = 2;
  void clear_password() ;
  const std::string& password() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_password(Arg_&& arg, Args_... args);
  std::string* mutable_password();
  PROTOBUF_NODISCARD std::string* release_password();
  void set_allocated_password(std::string* value);

  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(
      const std::string& value);
  std::string* _internal_mutable_password();

  public:
  // @@protoc_insertion_point(class_scope:hotelreservation.UserRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      53, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_UserRequest_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr username_;
    ::google::protobuf::internal::ArenaStringPtr password_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_hotel_5freservation_2eproto;
};
// -------------------------------------------------------------------

class User final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:hotelreservation.User) */ {
 public:
  inline User() : User(nullptr) {}
  ~User() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR User(
      ::google::protobuf::internal::ConstantInitialized);

  inline User(const User& from) : User(nullptr, from) {}
  inline User(User&& from) noexcept
      : User(nullptr, std::move(from)) {}
  inline User& operator=(const User& from) {
    CopyFrom(from);
    return *this;
  }
  inline User& operator=(User&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const User& default_instance() {
    return *internal_default_instance();
  }
  static inline const User* internal_default_instance() {
    return reinterpret_cast<const User*>(
        &_User_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(User& a, User& b) { a.Swap(&b); }
  inline void Swap(User* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(User* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  User* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<User>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const User& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const User& from) { User::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(User* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "hotelreservation.User"; }

 protected:
  explicit User(::google::protobuf::Arena* arena);
  User(::google::protobuf::Arena* arena, const User& from);
  User(::google::protobuf::Arena* arena, User&& from) noexcept
      : User(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // schemas for IAA/DSA ---------------------------------------------
  void generate_schema(std::vector<std::tuple<uint8_t*, size_t>> &schema) {
      schema.push_back(std::make_tuple(reinterpret_cast<uint8_t*>(const_cast<char*>(username().c_str())), username().size()));
      schema.push_back(std::make_tuple(reinterpret_cast<uint8_t*>(const_cast<char*>(password().c_str())), password().size()));
  }
  void generate_seperated_schema(std::vector<uint8_t*> &ptrs_list, std::vector<size_t> &sizes_list) {
      ptrs_list.push_back(nullptr);
      sizes_list.push_back(0);
      ptrs_list.push_back(reinterpret_cast<uint8_t*>(const_cast<char*>(username().c_str())));
      sizes_list.push_back(username().size());
      ptrs_list.push_back(reinterpret_cast<uint8_t*>(const_cast<char*>(password().c_str())));
      sizes_list.push_back(password().size());
  }
  void generate_scatter_ptrs(std::vector<uint8_t*> &ptrs) {
      ptrs.push_back(nullptr);
      ptrs.push_back(reinterpret_cast<uint8_t*>(const_cast<char*>(username().c_str())));
      ptrs.push_back(reinterpret_cast<uint8_t*>(const_cast<char*>(password().c_str())));
  }
  void generate_scatter_sizes(std::vector<size_t> &sizes) {
      sizes.push_back(0);
      sizes.push_back(username().size());
      sizes.push_back(password().size());
  }
  size_t generate_scatter_ptrs_and_allocate_from_sizes(std::vector<uint8_t*> &ptrs, std::vector<size_t> &sizes, size_t idx = 0) {
      idx++;
      // only primitive field pointers
      ptrs.push_back(nullptr);
      // non-primitive field pointers + allocation
      // allocate
      {
      std::string tmp_str(sizes[idx++], 'x');  // Preallocate needed size
      set_username(std::move(tmp_str));
      }
      //std::string tmp_str1(sizes[idx++], 'x');  // Preallocate needed size
      //set_username(std::move(tmp_str1));
      // store pointer in the pointers list
      ptrs.push_back(reinterpret_cast<uint8_t*>(const_cast<char*>(username().c_str())));
      // allocate
      {
      std::string tmp_str(sizes[idx++], 'x');  // Preallocate needed size
      set_password(std::move(tmp_str));
      }
      //std::string tmp_str2(sizes[idx++], 'x');  // Preallocate needed size
      //set_password(std::move(tmp_str2));
      // store pointer in the pointers list
      ptrs.push_back(reinterpret_cast<uint8_t*>(const_cast<char*>(password().c_str())));
      return idx;
  }
  size_t allocate_from_sizes(std::vector<size_t> &sizes, size_t idx = 0) {
      idx++;
      {
        std::string tmp_str(sizes[idx++], 'x');  // Preallocate needed size
        set_username(std::move(tmp_str));
      }
      {
        std::string tmp_str(sizes[idx++], 'x');  // Preallocate needed size
        set_password(std::move(tmp_str));
      }
      return idx;
  }

  // accessors -------------------------------------------------------
  enum : int {
    kUsernameFieldNumber = 1,
    kPasswordFieldNumber = 2,
  };
  // string username = 1;
  void clear_username() ;
  const std::string& username() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_username(Arg_&& arg, Args_... args);
  std::string* mutable_username();
  PROTOBUF_NODISCARD std::string* release_username();
  void set_allocated_username(std::string* value);

  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(
      const std::string& value);
  std::string* _internal_mutable_username();

  public:
  // string password = 2;
  void clear_password() ;
  const std::string& password() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_password(Arg_&& arg, Args_... args);
  std::string* mutable_password();
  PROTOBUF_NODISCARD std::string* release_password();
  void set_allocated_password(std::string* value);

  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(
      const std::string& value);
  std::string* _internal_mutable_password();

  public:
  // @@protoc_insertion_point(class_scope:hotelreservation.User)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      46, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_User_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr username_;
    ::google::protobuf::internal::ArenaStringPtr password_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_hotel_5freservation_2eproto;
};
// -------------------------------------------------------------------

class SearchRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:hotelreservation.SearchRequest) */ {
 public:
  inline SearchRequest() : SearchRequest(nullptr) {}
  ~SearchRequest() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SearchRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline SearchRequest(const SearchRequest& from) : SearchRequest(nullptr, from) {}
  inline SearchRequest(SearchRequest&& from) noexcept
      : SearchRequest(nullptr, std::move(from)) {}
  inline SearchRequest& operator=(const SearchRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SearchRequest& operator=(SearchRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SearchRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SearchRequest* internal_default_instance() {
    return reinterpret_cast<const SearchRequest*>(
        &_SearchRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 9;
  friend void swap(SearchRequest& a, SearchRequest& b) { a.Swap(&b); }
  inline void Swap(SearchRequest* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SearchRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SearchRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<SearchRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SearchRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SearchRequest& from) { SearchRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SearchRequest* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "hotelreservation.SearchRequest"; }

 protected:
  explicit SearchRequest(::google::protobuf::Arena* arena);
  SearchRequest(::google::protobuf::Arena* arena, const SearchRequest& from);
  SearchRequest(::google::protobuf::Arena* arena, SearchRequest&& from) noexcept
      : SearchRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // schemas for IAA/DSA ---------------------------------------------
  void generate_schema(std::vector<std::tuple<uint8_t*, size_t>> &schema) {
      auto start_addr = reinterpret_cast<uint8_t*>(&_impl_.lat_);
      auto end_addr = reinterpret_cast<uint8_t*>(&_impl_.lon_);
      schema.push_back(std::make_tuple(start_addr, end_addr - start_addr + sizeof(lon())));
      schema.push_back(std::make_tuple(reinterpret_cast<uint8_t*>(const_cast<char*>(customer_name().c_str())), customer_name().size()));
      schema.push_back(std::make_tuple(reinterpret_cast<uint8_t*>(const_cast<char*>(in_date().c_str())), in_date().size()));
      schema.push_back(std::make_tuple(reinterpret_cast<uint8_t*>(const_cast<char*>(out_date().c_str())), out_date().size()));
      schema.push_back(std::make_tuple(reinterpret_cast<uint8_t*>(const_cast<char*>(locale().c_str())), locale().size()));
  }
  void generate_seperated_schema(std::vector<uint8_t*> &ptrs_list, std::vector<size_t> &sizes_list) {
      auto start_addr = reinterpret_cast<uint8_t*>(&_impl_.lat_);
      auto end_addr = reinterpret_cast<uint8_t*>(&_impl_.lon_);
      ptrs_list.push_back(start_addr);
      sizes_list.push_back(end_addr - start_addr + sizeof(lon()));
      ptrs_list.push_back(reinterpret_cast<uint8_t*>(const_cast<char*>(customer_name().c_str())));
      sizes_list.push_back(customer_name().size());
      ptrs_list.push_back(reinterpret_cast<uint8_t*>(const_cast<char*>(in_date().c_str())));
      sizes_list.push_back(in_date().size());
      ptrs_list.push_back(reinterpret_cast<uint8_t*>(const_cast<char*>(out_date().c_str())));
      sizes_list.push_back(out_date().size());
      ptrs_list.push_back(reinterpret_cast<uint8_t*>(const_cast<char*>(locale().c_str())));
      sizes_list.push_back(locale().size());
  }
  void generate_scatter_ptrs(std::vector<uint8_t*> &ptrs) {
      auto start_addr = reinterpret_cast<uint8_t*>(&_impl_.lat_);
      //auto end_addr = reinterpret_cast<uint8_t*>(&_impl_.lon_);
      ptrs.push_back(start_addr);
      ptrs.push_back(reinterpret_cast<uint8_t*>(const_cast<char*>(customer_name().c_str())));
      ptrs.push_back(reinterpret_cast<uint8_t*>(const_cast<char*>(in_date().c_str())));
      ptrs.push_back(reinterpret_cast<uint8_t*>(const_cast<char*>(out_date().c_str())));
      ptrs.push_back(reinterpret_cast<uint8_t*>(const_cast<char*>(locale().c_str())));
  }
  void generate_scatter_sizes(std::vector<size_t> &sizes) {
      auto start_addr = reinterpret_cast<uint8_t*>(&_impl_.lat_);
      auto end_addr = reinterpret_cast<uint8_t*>(&_impl_.lon_);
      sizes.push_back(end_addr - start_addr + sizeof(lon()));
      sizes.push_back(customer_name().size());
      sizes.push_back(in_date().size());
      sizes.push_back(out_date().size());
      sizes.push_back(locale().size());
  }
  size_t generate_scatter_ptrs_and_allocate_from_sizes(std::vector<uint8_t*> &ptrs, std::vector<size_t> &sizes, size_t idx = 0) {
      idx++;
      // only primitive field pointers
      auto start_addr = reinterpret_cast<uint8_t*>(&_impl_.lat_);
      //auto end_addr = reinterpret_cast<uint8_t*>(&_impl_.lon_);
      ptrs.push_back(start_addr);
      // non-primitive field pointers + allocation
      // allocate
      {
      std::string tmp_str(sizes[idx++], 'x');  // Preallocate needed size
      set_customer_name(std::move(tmp_str));
      }
      //std::string tmp_str1(sizes[idx++], 'x');  // Preallocate needed size
      //set_customer_name(std::move(tmp_str1));
      // store pointer in the pointers list
      ptrs.push_back(reinterpret_cast<uint8_t*>(const_cast<char*>(customer_name().c_str())));
      // allocate
      {
      std::string tmp_str(sizes[idx++], 'x');  // Preallocate needed size
      set_in_date(std::move(tmp_str));
      }
      //std::string tmp_str2(sizes[idx++], 'x');  // Preallocate needed size
      //set_in_date(std::move(tmp_str2));
      // store pointer in the pointers list
      ptrs.push_back(reinterpret_cast<uint8_t*>(const_cast<char*>(in_date().c_str())));
      // allocate
      {
      std::string tmp_str(sizes[idx++], 'x');  // Preallocate needed size
      set_out_date(std::move(tmp_str));
      }
      //std::string tmp_str3(sizes[idx++], 'x');  // Preallocate needed size
      //set_out_date(std::move(tmp_str3));
      // store pointer in the pointers list
      ptrs.push_back(reinterpret_cast<uint8_t*>(const_cast<char*>(out_date().c_str())));
      // allocate
      {
      std::string tmp_str(sizes[idx++], 'x');  // Preallocate needed size
      set_locale(std::move(tmp_str));
      }
      //std::string tmp_str4(sizes[idx++], 'x');  // Preallocate needed size
      //set_locale(std::move(tmp_str4));
      // store pointer in the pointers list
      ptrs.push_back(reinterpret_cast<uint8_t*>(const_cast<char*>(locale().c_str())));
      return idx;
  }
  size_t allocate_from_sizes(std::vector<size_t> &sizes, size_t idx = 0) {
      idx++;
      {
        std::string tmp_str(sizes[idx++], 'x');  // Preallocate needed size
        set_customer_name(std::move(tmp_str));
      }
      {
        std::string tmp_str(sizes[idx++], 'x');  // Preallocate needed size
        set_in_date(std::move(tmp_str));
      }
      {
        std::string tmp_str(sizes[idx++], 'x');  // Preallocate needed size
        set_out_date(std::move(tmp_str));
      }
      {
        std::string tmp_str(sizes[idx++], 'x');  // Preallocate needed size
        set_locale(std::move(tmp_str));
      }
      return idx;
  }

  // accessors -------------------------------------------------------
  enum : int {
    kCustomerNameFieldNumber = 1,
    kInDateFieldNumber = 2,
    kOutDateFieldNumber = 3,
    kLocaleFieldNumber = 6,
    kLatFieldNumber = 4,
    kLonFieldNumber = 5,
  };
  // string customer_name = 1;
  void clear_customer_name() ;
  const std::string& customer_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_customer_name(Arg_&& arg, Args_... args);
  std::string* mutable_customer_name();
  PROTOBUF_NODISCARD std::string* release_customer_name();
  void set_allocated_customer_name(std::string* value);

  private:
  const std::string& _internal_customer_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_customer_name(
      const std::string& value);
  std::string* _internal_mutable_customer_name();

  public:
  // string in_date = 2;
  void clear_in_date() ;
  const std::string& in_date() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_in_date(Arg_&& arg, Args_... args);
  std::string* mutable_in_date();
  PROTOBUF_NODISCARD std::string* release_in_date();
  void set_allocated_in_date(std::string* value);

  private:
  const std::string& _internal_in_date() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_in_date(
      const std::string& value);
  std::string* _internal_mutable_in_date();

  public:
  // string out_date = 3;
  void clear_out_date() ;
  const std::string& out_date() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_out_date(Arg_&& arg, Args_... args);
  std::string* mutable_out_date();
  PROTOBUF_NODISCARD std::string* release_out_date();
  void set_allocated_out_date(std::string* value);

  private:
  const std::string& _internal_out_date() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_out_date(
      const std::string& value);
  std::string* _internal_mutable_out_date();

  public:
  // string locale = 6;
  void clear_locale() ;
  const std::string& locale() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_locale(Arg_&& arg, Args_... args);
  std::string* mutable_locale();
  PROTOBUF_NODISCARD std::string* release_locale();
  void set_allocated_locale(std::string* value);

  private:
  const std::string& _internal_locale() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_locale(
      const std::string& value);
  std::string* _internal_mutable_locale();

  public:
  // double lat = 4;
  void clear_lat() ;
  double lat() const;
  void set_lat(double value);

  private:
  double _internal_lat() const;
  void _internal_set_lat(double value);

  public:
  // double lon = 5;
  void clear_lon() ;
  double lon() const;
  void set_lon(double value);

  private:
  double _internal_lon() const;
  void _internal_set_lon(double value);

  public:
  // @@protoc_insertion_point(class_scope:hotelreservation.SearchRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 0,
      73, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_SearchRequest_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr customer_name_;
    ::google::protobuf::internal::ArenaStringPtr in_date_;
    ::google::protobuf::internal::ArenaStringPtr out_date_;
    ::google::protobuf::internal::ArenaStringPtr locale_;
    double lat_;
    double lon_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_hotel_5freservation_2eproto;
};
// -------------------------------------------------------------------

class RoomType final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:hotelreservation.RoomType) */ {
 public:
  inline RoomType() : RoomType(nullptr) {}
  ~RoomType() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RoomType(
      ::google::protobuf::internal::ConstantInitialized);

  inline RoomType(const RoomType& from) : RoomType(nullptr, from) {}
  inline RoomType(RoomType&& from) noexcept
      : RoomType(nullptr, std::move(from)) {}
  inline RoomType& operator=(const RoomType& from) {
    CopyFrom(from);
    return *this;
  }
  inline RoomType& operator=(RoomType&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RoomType& default_instance() {
    return *internal_default_instance();
  }
  static inline const RoomType* internal_default_instance() {
    return reinterpret_cast<const RoomType*>(
        &_RoomType_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 2;
  friend void swap(RoomType& a, RoomType& b) { a.Swap(&b); }
  inline void Swap(RoomType* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RoomType* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RoomType* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<RoomType>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RoomType& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RoomType& from) { RoomType::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RoomType* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "hotelreservation.RoomType"; }

 protected:
  explicit RoomType(::google::protobuf::Arena* arena);
  RoomType(::google::protobuf::Arena* arena, const RoomType& from);
  RoomType(::google::protobuf::Arena* arena, RoomType&& from) noexcept
      : RoomType(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // schemas for IAA/DSA ---------------------------------------------
  void generate_schema(std::vector<std::tuple<uint8_t*, size_t>> &schema) {
      auto start_addr = reinterpret_cast<uint8_t*>(&_impl_.bookable_rate_);
      auto end_addr = reinterpret_cast<uint8_t*>(&_impl_.total_rate_inclusive_);
      schema.push_back(std::make_tuple(start_addr, end_addr - start_addr + sizeof(total_rate_inclusive())));
      schema.push_back(std::make_tuple(reinterpret_cast<uint8_t*>(const_cast<char*>(code().c_str())), code().size()));
      schema.push_back(std::make_tuple(reinterpret_cast<uint8_t*>(const_cast<char*>(room_description().c_str())), room_description().size()));
  }
  void generate_seperated_schema(std::vector<uint8_t*> &ptrs_list, std::vector<size_t> &sizes_list) {
      auto start_addr = reinterpret_cast<uint8_t*>(&_impl_.bookable_rate_);
      auto end_addr = reinterpret_cast<uint8_t*>(&_impl_.total_rate_inclusive_);
      ptrs_list.push_back(start_addr);
      sizes_list.push_back(end_addr - start_addr + sizeof(total_rate_inclusive()));
      ptrs_list.push_back(reinterpret_cast<uint8_t*>(const_cast<char*>(code().c_str())));
      sizes_list.push_back(code().size());
      ptrs_list.push_back(reinterpret_cast<uint8_t*>(const_cast<char*>(room_description().c_str())));
      sizes_list.push_back(room_description().size());
  }
  void generate_scatter_ptrs(std::vector<uint8_t*> &ptrs) {
      auto start_addr = reinterpret_cast<uint8_t*>(&_impl_.bookable_rate_);
      //auto end_addr = reinterpret_cast<uint8_t*>(&_impl_.total_rate_inclusive_);
      ptrs.push_back(start_addr);
      ptrs.push_back(reinterpret_cast<uint8_t*>(const_cast<char*>(code().c_str())));
      ptrs.push_back(reinterpret_cast<uint8_t*>(const_cast<char*>(room_description().c_str())));
  }
  void generate_scatter_sizes(std::vector<size_t> &sizes) {
      auto start_addr = reinterpret_cast<uint8_t*>(&_impl_.bookable_rate_);
      auto end_addr = reinterpret_cast<uint8_t*>(&_impl_.total_rate_inclusive_);
      sizes.push_back(end_addr - start_addr + sizeof(total_rate_inclusive()));
      sizes.push_back(code().size());
      sizes.push_back(room_description().size());
  }
  size_t generate_scatter_ptrs_and_allocate_from_sizes(std::vector<uint8_t*> &ptrs, std::vector<size_t> &sizes, size_t idx = 0) {
      idx++;
      // only primitive field pointers
      auto start_addr = reinterpret_cast<uint8_t*>(&_impl_.bookable_rate_);
      //auto end_addr = reinterpret_cast<uint8_t*>(&_impl_.total_rate_inclusive_);
      ptrs.push_back(start_addr);
      // non-primitive field pointers + allocation
      // allocate
      {
      std::string tmp_str(sizes[idx++], 'x');  // Preallocate needed size
      set_code(std::move(tmp_str));
      }
      //std::string tmp_str1(sizes[idx++], 'x');  // Preallocate needed size
      //set_code(std::move(tmp_str1));
      // store pointer in the pointers list
      ptrs.push_back(reinterpret_cast<uint8_t*>(const_cast<char*>(code().c_str())));
      // allocate
      {
      std::string tmp_str(sizes[idx++], 'x');  // Preallocate needed size
      set_room_description(std::move(tmp_str));
      }
      //std::string tmp_str2(sizes[idx++], 'x');  // Preallocate needed size
      //set_room_description(std::move(tmp_str2));
      // store pointer in the pointers list
      ptrs.push_back(reinterpret_cast<uint8_t*>(const_cast<char*>(room_description().c_str())));
      return idx;
  }
  size_t allocate_from_sizes(std::vector<size_t> &sizes, size_t idx = 0) {
      idx++;
      {
        std::string tmp_str(sizes[idx++], 'x');  // Preallocate needed size
        set_code(std::move(tmp_str));
      }
      {
        std::string tmp_str(sizes[idx++], 'x');  // Preallocate needed size
        set_room_description(std::move(tmp_str));
      }
      return idx;
  }

  // accessors -------------------------------------------------------
  enum : int {
    kCodeFieldNumber = 2,
    kRoomDescriptionFieldNumber = 3,
    kBookableRateFieldNumber = 1,
    kTotalRateFieldNumber = 4,
    kTotalRateInclusiveFieldNumber = 5,
  };
  // string code = 2;
  void clear_code() ;
  const std::string& code() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_code(Arg_&& arg, Args_... args);
  std::string* mutable_code();
  PROTOBUF_NODISCARD std::string* release_code();
  void set_allocated_code(std::string* value);

  private:
  const std::string& _internal_code() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_code(
      const std::string& value);
  std::string* _internal_mutable_code();

  public:
  // string room_description = 3;
  void clear_room_description() ;
  const std::string& room_description() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_room_description(Arg_&& arg, Args_... args);
  std::string* mutable_room_description();
  PROTOBUF_NODISCARD std::string* release_room_description();
  void set_allocated_room_description(std::string* value);

  private:
  const std::string& _internal_room_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_room_description(
      const std::string& value);
  std::string* _internal_mutable_room_description();

  public:
  // double bookable_rate = 1;
  void clear_bookable_rate() ;
  double bookable_rate() const;
  void set_bookable_rate(double value);

  private:
  double _internal_bookable_rate() const;
  void _internal_set_bookable_rate(double value);

  public:
  // double total_rate = 4;
  void clear_total_rate() ;
  double total_rate() const;
  void set_total_rate(double value);

  private:
  double _internal_total_rate() const;
  void _internal_set_total_rate(double value);

  public:
  // double total_rate_inclusive = 5;
  void clear_total_rate_inclusive() ;
  double total_rate_inclusive() const;
  void set_total_rate_inclusive(double value);

  private:
  double _internal_total_rate_inclusive() const;
  void _internal_set_total_rate_inclusive(double value);

  public:
  // @@protoc_insertion_point(class_scope:hotelreservation.RoomType)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 0,
      54, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_RoomType_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr code_;
    ::google::protobuf::internal::ArenaStringPtr room_description_;
    double bookable_rate_;
    double total_rate_;
    double total_rate_inclusive_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_hotel_5freservation_2eproto;
};
// -------------------------------------------------------------------

class ReservationResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:hotelreservation.ReservationResponse) */ {
 public:
  inline ReservationResponse() : ReservationResponse(nullptr) {}
  ~ReservationResponse() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ReservationResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline ReservationResponse(const ReservationResponse& from) : ReservationResponse(nullptr, from) {}
  inline ReservationResponse(ReservationResponse&& from) noexcept
      : ReservationResponse(nullptr, std::move(from)) {}
  inline ReservationResponse& operator=(const ReservationResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReservationResponse& operator=(ReservationResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReservationResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReservationResponse* internal_default_instance() {
    return reinterpret_cast<const ReservationResponse*>(
        &_ReservationResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 16;
  friend void swap(ReservationResponse& a, ReservationResponse& b) { a.Swap(&b); }
  inline void Swap(ReservationResponse* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReservationResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReservationResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<ReservationResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ReservationResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ReservationResponse& from) { ReservationResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ReservationResponse* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "hotelreservation.ReservationResponse"; }

 protected:
  explicit ReservationResponse(::google::protobuf::Arena* arena);
  ReservationResponse(::google::protobuf::Arena* arena, const ReservationResponse& from);
  ReservationResponse(::google::protobuf::Arena* arena, ReservationResponse&& from) noexcept
      : ReservationResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // schemas for IAA/DSA ---------------------------------------------
  void generate_schema(std::vector<std::tuple<uint8_t*, size_t>> &schema) {
      schema.push_back(std::make_tuple(reinterpret_cast<uint8_t*>(const_cast<char*>(message().c_str())), message().size()));
  }
  void generate_seperated_schema(std::vector<uint8_t*> &ptrs_list, std::vector<size_t> &sizes_list) {
      ptrs_list.push_back(nullptr);
      sizes_list.push_back(0);
      ptrs_list.push_back(reinterpret_cast<uint8_t*>(const_cast<char*>(message().c_str())));
      sizes_list.push_back(message().size());
  }
  void generate_scatter_ptrs(std::vector<uint8_t*> &ptrs) {
      ptrs.push_back(nullptr);
      ptrs.push_back(reinterpret_cast<uint8_t*>(const_cast<char*>(message().c_str())));
  }
  void generate_scatter_sizes(std::vector<size_t> &sizes) {
      sizes.push_back(0);
      sizes.push_back(message().size());
  }
  size_t generate_scatter_ptrs_and_allocate_from_sizes(std::vector<uint8_t*> &ptrs, std::vector<size_t> &sizes, size_t idx = 0) {
      idx++;
      // only primitive field pointers
      ptrs.push_back(nullptr);
      // non-primitive field pointers + allocation
      // allocate
      {
      std::string tmp_str(sizes[idx++], 'x');  // Preallocate needed size
      set_message(std::move(tmp_str));
      }
      //std::string tmp_str1(sizes[idx++], 'x');  // Preallocate needed size
      //set_message(std::move(tmp_str1));
      // store pointer in the pointers list
      ptrs.push_back(reinterpret_cast<uint8_t*>(const_cast<char*>(message().c_str())));
      return idx;
  }
  size_t allocate_from_sizes(std::vector<size_t> &sizes, size_t idx = 0) {
      idx++;
      {
        std::string tmp_str(sizes[idx++], 'x');  // Preallocate needed size
        set_message(std::move(tmp_str));
      }
      return idx;
  }

  // accessors -------------------------------------------------------
  enum : int {
    kMessageFieldNumber = 1,
  };
  // string message = 1;
  void clear_message() ;
  const std::string& message() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_message(Arg_&& arg, Args_... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* value);

  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(
      const std::string& value);
  std::string* _internal_mutable_message();

  public:
  // @@protoc_insertion_point(class_scope:hotelreservation.ReservationResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      52, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_ReservationResponse_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr message_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_hotel_5freservation_2eproto;
};
// -------------------------------------------------------------------

class ReservationRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:hotelreservation.ReservationRequest) */ {
 public:
  inline ReservationRequest() : ReservationRequest(nullptr) {}
  ~ReservationRequest() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ReservationRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline ReservationRequest(const ReservationRequest& from) : ReservationRequest(nullptr, from) {}
  inline ReservationRequest(ReservationRequest&& from) noexcept
      : ReservationRequest(nullptr, std::move(from)) {}
  inline ReservationRequest& operator=(const ReservationRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReservationRequest& operator=(ReservationRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReservationRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReservationRequest* internal_default_instance() {
    return reinterpret_cast<const ReservationRequest*>(
        &_ReservationRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 15;
  friend void swap(ReservationRequest& a, ReservationRequest& b) { a.Swap(&b); }
  inline void Swap(ReservationRequest* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReservationRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReservationRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<ReservationRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ReservationRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ReservationRequest& from) { ReservationRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ReservationRequest* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "hotelreservation.ReservationRequest"; }

 protected:
  explicit ReservationRequest(::google::protobuf::Arena* arena);
  ReservationRequest(::google::protobuf::Arena* arena, const ReservationRequest& from);
  ReservationRequest(::google::protobuf::Arena* arena, ReservationRequest&& from) noexcept
      : ReservationRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // schemas for IAA/DSA ---------------------------------------------
  void generate_schema(std::vector<std::tuple<uint8_t*, size_t>> &schema) {
      auto start_addr = reinterpret_cast<uint8_t*>(&_impl_.room_number_);
      auto end_addr = reinterpret_cast<uint8_t*>(&_impl_.room_number_);
      schema.push_back(std::make_tuple(start_addr, end_addr - start_addr + sizeof(room_number())));
      schema.push_back(std::make_tuple(reinterpret_cast<uint8_t*>(const_cast<char*>(in_date().c_str())), in_date().size()));
      schema.push_back(std::make_tuple(reinterpret_cast<uint8_t*>(const_cast<char*>(out_date().c_str())), out_date().size()));
      schema.push_back(std::make_tuple(reinterpret_cast<uint8_t*>(const_cast<char*>(hotel_id().c_str())), hotel_id().size()));
      schema.push_back(std::make_tuple(reinterpret_cast<uint8_t*>(const_cast<char*>(customer_name().c_str())), customer_name().size()));
      schema.push_back(std::make_tuple(reinterpret_cast<uint8_t*>(const_cast<char*>(username().c_str())), username().size()));
      schema.push_back(std::make_tuple(reinterpret_cast<uint8_t*>(const_cast<char*>(password().c_str())), password().size()));
  }
  void generate_seperated_schema(std::vector<uint8_t*> &ptrs_list, std::vector<size_t> &sizes_list) {
      auto start_addr = reinterpret_cast<uint8_t*>(&_impl_.room_number_);
      auto end_addr = reinterpret_cast<uint8_t*>(&_impl_.room_number_);
      ptrs_list.push_back(start_addr);
      sizes_list.push_back(end_addr - start_addr + sizeof(room_number()));
      ptrs_list.push_back(reinterpret_cast<uint8_t*>(const_cast<char*>(in_date().c_str())));
      sizes_list.push_back(in_date().size());
      ptrs_list.push_back(reinterpret_cast<uint8_t*>(const_cast<char*>(out_date().c_str())));
      sizes_list.push_back(out_date().size());
      ptrs_list.push_back(reinterpret_cast<uint8_t*>(const_cast<char*>(hotel_id().c_str())));
      sizes_list.push_back(hotel_id().size());
      ptrs_list.push_back(reinterpret_cast<uint8_t*>(const_cast<char*>(customer_name().c_str())));
      sizes_list.push_back(customer_name().size());
      ptrs_list.push_back(reinterpret_cast<uint8_t*>(const_cast<char*>(username().c_str())));
      sizes_list.push_back(username().size());
      ptrs_list.push_back(reinterpret_cast<uint8_t*>(const_cast<char*>(password().c_str())));
      sizes_list.push_back(password().size());
  }
  void generate_scatter_ptrs(std::vector<uint8_t*> &ptrs) {
      auto start_addr = reinterpret_cast<uint8_t*>(&_impl_.room_number_);
      //auto end_addr = reinterpret_cast<uint8_t*>(&_impl_.room_number_);
      ptrs.push_back(start_addr);
      ptrs.push_back(reinterpret_cast<uint8_t*>(const_cast<char*>(in_date().c_str())));
      ptrs.push_back(reinterpret_cast<uint8_t*>(const_cast<char*>(out_date().c_str())));
      ptrs.push_back(reinterpret_cast<uint8_t*>(const_cast<char*>(hotel_id().c_str())));
      ptrs.push_back(reinterpret_cast<uint8_t*>(const_cast<char*>(customer_name().c_str())));
      ptrs.push_back(reinterpret_cast<uint8_t*>(const_cast<char*>(username().c_str())));
      ptrs.push_back(reinterpret_cast<uint8_t*>(const_cast<char*>(password().c_str())));
  }
  void generate_scatter_sizes(std::vector<size_t> &sizes) {
      auto start_addr = reinterpret_cast<uint8_t*>(&_impl_.room_number_);
      auto end_addr = reinterpret_cast<uint8_t*>(&_impl_.room_number_);
      sizes.push_back(end_addr - start_addr + sizeof(room_number()));
      sizes.push_back(in_date().size());
      sizes.push_back(out_date().size());
      sizes.push_back(hotel_id().size());
      sizes.push_back(customer_name().size());
      sizes.push_back(username().size());
      sizes.push_back(password().size());
  }
  size_t generate_scatter_ptrs_and_allocate_from_sizes(std::vector<uint8_t*> &ptrs, std::vector<size_t> &sizes, size_t idx = 0) {
      idx++;
      // only primitive field pointers
      auto start_addr = reinterpret_cast<uint8_t*>(&_impl_.room_number_);
      //auto end_addr = reinterpret_cast<uint8_t*>(&_impl_.room_number_);
      ptrs.push_back(start_addr);
      // non-primitive field pointers + allocation
      // allocate
      {
      std::string tmp_str(sizes[idx++], 'x');  // Preallocate needed size
      set_in_date(std::move(tmp_str));
      }
      //std::string tmp_str1(sizes[idx++], 'x');  // Preallocate needed size
      //set_in_date(std::move(tmp_str1));
      // store pointer in the pointers list
      ptrs.push_back(reinterpret_cast<uint8_t*>(const_cast<char*>(in_date().c_str())));
      // allocate
      {
      std::string tmp_str(sizes[idx++], 'x');  // Preallocate needed size
      set_out_date(std::move(tmp_str));
      }
      //std::string tmp_str2(sizes[idx++], 'x');  // Preallocate needed size
      //set_out_date(std::move(tmp_str2));
      // store pointer in the pointers list
      ptrs.push_back(reinterpret_cast<uint8_t*>(const_cast<char*>(out_date().c_str())));
      // allocate
      {
      std::string tmp_str(sizes[idx++], 'x');  // Preallocate needed size
      set_hotel_id(std::move(tmp_str));
      }
      //std::string tmp_str3(sizes[idx++], 'x');  // Preallocate needed size
      //set_hotel_id(std::move(tmp_str3));
      // store pointer in the pointers list
      ptrs.push_back(reinterpret_cast<uint8_t*>(const_cast<char*>(hotel_id().c_str())));
      // allocate
      {
      std::string tmp_str(sizes[idx++], 'x');  // Preallocate needed size
      set_customer_name(std::move(tmp_str));
      }
      //std::string tmp_str4(sizes[idx++], 'x');  // Preallocate needed size
      //set_customer_name(std::move(tmp_str4));
      // store pointer in the pointers list
      ptrs.push_back(reinterpret_cast<uint8_t*>(const_cast<char*>(customer_name().c_str())));
      // allocate
      {
      std::string tmp_str(sizes[idx++], 'x');  // Preallocate needed size
      set_username(std::move(tmp_str));
      }
      //std::string tmp_str5(sizes[idx++], 'x');  // Preallocate needed size
      //set_username(std::move(tmp_str5));
      // store pointer in the pointers list
      ptrs.push_back(reinterpret_cast<uint8_t*>(const_cast<char*>(username().c_str())));
      // allocate
      {
      std::string tmp_str(sizes[idx++], 'x');  // Preallocate needed size
      set_password(std::move(tmp_str));
      }
      //std::string tmp_str6(sizes[idx++], 'x');  // Preallocate needed size
      //set_password(std::move(tmp_str6));
      // store pointer in the pointers list
      ptrs.push_back(reinterpret_cast<uint8_t*>(const_cast<char*>(password().c_str())));
      return idx;
  }
  size_t allocate_from_sizes(std::vector<size_t> &sizes, size_t idx = 0) {
      idx++;
      {
        std::string tmp_str(sizes[idx++], 'x');  // Preallocate needed size
        set_in_date(std::move(tmp_str));
      }
      {
        std::string tmp_str(sizes[idx++], 'x');  // Preallocate needed size
        set_out_date(std::move(tmp_str));
      }
      {
        std::string tmp_str(sizes[idx++], 'x');  // Preallocate needed size
        set_hotel_id(std::move(tmp_str));
      }
      {
        std::string tmp_str(sizes[idx++], 'x');  // Preallocate needed size
        set_customer_name(std::move(tmp_str));
      }
      {
        std::string tmp_str(sizes[idx++], 'x');  // Preallocate needed size
        set_username(std::move(tmp_str));
      }
      {
        std::string tmp_str(sizes[idx++], 'x');  // Preallocate needed size
        set_password(std::move(tmp_str));
      }
      return idx;
  }

  // accessors -------------------------------------------------------
  enum : int {
    kInDateFieldNumber = 1,
    kOutDateFieldNumber = 2,
    kHotelIdFieldNumber = 3,
    kCustomerNameFieldNumber = 4,
    kUsernameFieldNumber = 5,
    kPasswordFieldNumber = 6,
    kRoomNumberFieldNumber = 7,
  };
  // string in_date = 1;
  void clear_in_date() ;
  const std::string& in_date() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_in_date(Arg_&& arg, Args_... args);
  std::string* mutable_in_date();
  PROTOBUF_NODISCARD std::string* release_in_date();
  void set_allocated_in_date(std::string* value);

  private:
  const std::string& _internal_in_date() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_in_date(
      const std::string& value);
  std::string* _internal_mutable_in_date();

  public:
  // string out_date = 2;
  void clear_out_date() ;
  const std::string& out_date() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_out_date(Arg_&& arg, Args_... args);
  std::string* mutable_out_date();
  PROTOBUF_NODISCARD std::string* release_out_date();
  void set_allocated_out_date(std::string* value);

  private:
  const std::string& _internal_out_date() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_out_date(
      const std::string& value);
  std::string* _internal_mutable_out_date();

  public:
  // string hotel_id = 3;
  void clear_hotel_id() ;
  const std::string& hotel_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_hotel_id(Arg_&& arg, Args_... args);
  std::string* mutable_hotel_id();
  PROTOBUF_NODISCARD std::string* release_hotel_id();
  void set_allocated_hotel_id(std::string* value);

  private:
  const std::string& _internal_hotel_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hotel_id(
      const std::string& value);
  std::string* _internal_mutable_hotel_id();

  public:
  // string customer_name = 4;
  void clear_customer_name() ;
  const std::string& customer_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_customer_name(Arg_&& arg, Args_... args);
  std::string* mutable_customer_name();
  PROTOBUF_NODISCARD std::string* release_customer_name();
  void set_allocated_customer_name(std::string* value);

  private:
  const std::string& _internal_customer_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_customer_name(
      const std::string& value);
  std::string* _internal_mutable_customer_name();

  public:
  // string username = 5;
  void clear_username() ;
  const std::string& username() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_username(Arg_&& arg, Args_... args);
  std::string* mutable_username();
  PROTOBUF_NODISCARD std::string* release_username();
  void set_allocated_username(std::string* value);

  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(
      const std::string& value);
  std::string* _internal_mutable_username();

  public:
  // string password = 6;
  void clear_password() ;
  const std::string& password() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_password(Arg_&& arg, Args_... args);
  std::string* mutable_password();
  PROTOBUF_NODISCARD std::string* release_password();
  void set_allocated_password(std::string* value);

  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(
      const std::string& value);
  std::string* _internal_mutable_password();

  public:
  // int64 room_number = 7;
  void clear_room_number() ;
  ::int64_t room_number() const;
  void set_room_number(::int64_t value);

  private:
  ::int64_t _internal_room_number() const;
  void _internal_set_room_number(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:hotelreservation.ReservationRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 7, 0,
      96, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_ReservationRequest_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr in_date_;
    ::google::protobuf::internal::ArenaStringPtr out_date_;
    ::google::protobuf::internal::ArenaStringPtr hotel_id_;
    ::google::protobuf::internal::ArenaStringPtr customer_name_;
    ::google::protobuf::internal::ArenaStringPtr username_;
    ::google::protobuf::internal::ArenaStringPtr password_;
    ::int64_t room_number_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_hotel_5freservation_2eproto;
};
// -------------------------------------------------------------------

class Reservation final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:hotelreservation.Reservation) */ {
 public:
  inline Reservation() : Reservation(nullptr) {}
  ~Reservation() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Reservation(
      ::google::protobuf::internal::ConstantInitialized);

  inline Reservation(const Reservation& from) : Reservation(nullptr, from) {}
  inline Reservation(Reservation&& from) noexcept
      : Reservation(nullptr, std::move(from)) {}
  inline Reservation& operator=(const Reservation& from) {
    CopyFrom(from);
    return *this;
  }
  inline Reservation& operator=(Reservation&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Reservation& default_instance() {
    return *internal_default_instance();
  }
  static inline const Reservation* internal_default_instance() {
    return reinterpret_cast<const Reservation*>(
        &_Reservation_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 4;
  friend void swap(Reservation& a, Reservation& b) { a.Swap(&b); }
  inline void Swap(Reservation* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Reservation* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Reservation* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<Reservation>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Reservation& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Reservation& from) { Reservation::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Reservation* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "hotelreservation.Reservation"; }

 protected:
  explicit Reservation(::google::protobuf::Arena* arena);
  Reservation(::google::protobuf::Arena* arena, const Reservation& from);
  Reservation(::google::protobuf::Arena* arena, Reservation&& from) noexcept
      : Reservation(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // schemas for IAA/DSA ---------------------------------------------
  void generate_schema(std::vector<std::tuple<uint8_t*, size_t>> &schema) {
      auto start_addr = reinterpret_cast<uint8_t*>(&_impl_.number_);
      auto end_addr = reinterpret_cast<uint8_t*>(&_impl_.number_);
      schema.push_back(std::make_tuple(start_addr, end_addr - start_addr + sizeof(number())));
      schema.push_back(std::make_tuple(reinterpret_cast<uint8_t*>(const_cast<char*>(hotel_id().c_str())), hotel_id().size()));
      schema.push_back(std::make_tuple(reinterpret_cast<uint8_t*>(const_cast<char*>(customer_name().c_str())), customer_name().size()));
      schema.push_back(std::make_tuple(reinterpret_cast<uint8_t*>(const_cast<char*>(in_date().c_str())), in_date().size()));
      schema.push_back(std::make_tuple(reinterpret_cast<uint8_t*>(const_cast<char*>(out_date().c_str())), out_date().size()));
  }
  void generate_seperated_schema(std::vector<uint8_t*> &ptrs_list, std::vector<size_t> &sizes_list) {
      auto start_addr = reinterpret_cast<uint8_t*>(&_impl_.number_);
      auto end_addr = reinterpret_cast<uint8_t*>(&_impl_.number_);
      ptrs_list.push_back(start_addr);
      sizes_list.push_back(end_addr - start_addr + sizeof(number()));
      ptrs_list.push_back(reinterpret_cast<uint8_t*>(const_cast<char*>(hotel_id().c_str())));
      sizes_list.push_back(hotel_id().size());
      ptrs_list.push_back(reinterpret_cast<uint8_t*>(const_cast<char*>(customer_name().c_str())));
      sizes_list.push_back(customer_name().size());
      ptrs_list.push_back(reinterpret_cast<uint8_t*>(const_cast<char*>(in_date().c_str())));
      sizes_list.push_back(in_date().size());
      ptrs_list.push_back(reinterpret_cast<uint8_t*>(const_cast<char*>(out_date().c_str())));
      sizes_list.push_back(out_date().size());
  }
  void generate_scatter_ptrs(std::vector<uint8_t*> &ptrs) {
      auto start_addr = reinterpret_cast<uint8_t*>(&_impl_.number_);
      //auto end_addr = reinterpret_cast<uint8_t*>(&_impl_.number_);
      ptrs.push_back(start_addr);
      ptrs.push_back(reinterpret_cast<uint8_t*>(const_cast<char*>(hotel_id().c_str())));
      ptrs.push_back(reinterpret_cast<uint8_t*>(const_cast<char*>(customer_name().c_str())));
      ptrs.push_back(reinterpret_cast<uint8_t*>(const_cast<char*>(in_date().c_str())));
      ptrs.push_back(reinterpret_cast<uint8_t*>(const_cast<char*>(out_date().c_str())));
  }
  void generate_scatter_sizes(std::vector<size_t> &sizes) {
      auto start_addr = reinterpret_cast<uint8_t*>(&_impl_.number_);
      auto end_addr = reinterpret_cast<uint8_t*>(&_impl_.number_);
      sizes.push_back(end_addr - start_addr + sizeof(number()));
      sizes.push_back(hotel_id().size());
      sizes.push_back(customer_name().size());
      sizes.push_back(in_date().size());
      sizes.push_back(out_date().size());
  }
  size_t generate_scatter_ptrs_and_allocate_from_sizes(std::vector<uint8_t*> &ptrs, std::vector<size_t> &sizes, size_t idx = 0) {
      idx++;
      // only primitive field pointers
      auto start_addr = reinterpret_cast<uint8_t*>(&_impl_.number_);
      //auto end_addr = reinterpret_cast<uint8_t*>(&_impl_.number_);
      ptrs.push_back(start_addr);
      // non-primitive field pointers + allocation
      // allocate
      {
      std::string tmp_str(sizes[idx++], 'x');  // Preallocate needed size
      set_hotel_id(std::move(tmp_str));
      }
      //std::string tmp_str1(sizes[idx++], 'x');  // Preallocate needed size
      //set_hotel_id(std::move(tmp_str1));
      // store pointer in the pointers list
      ptrs.push_back(reinterpret_cast<uint8_t*>(const_cast<char*>(hotel_id().c_str())));
      // allocate
      {
      std::string tmp_str(sizes[idx++], 'x');  // Preallocate needed size
      set_customer_name(std::move(tmp_str));
      }
      //std::string tmp_str2(sizes[idx++], 'x');  // Preallocate needed size
      //set_customer_name(std::move(tmp_str2));
      // store pointer in the pointers list
      ptrs.push_back(reinterpret_cast<uint8_t*>(const_cast<char*>(customer_name().c_str())));
      // allocate
      {
      std::string tmp_str(sizes[idx++], 'x');  // Preallocate needed size
      set_in_date(std::move(tmp_str));
      }
      //std::string tmp_str3(sizes[idx++], 'x');  // Preallocate needed size
      //set_in_date(std::move(tmp_str3));
      // store pointer in the pointers list
      ptrs.push_back(reinterpret_cast<uint8_t*>(const_cast<char*>(in_date().c_str())));
      // allocate
      {
      std::string tmp_str(sizes[idx++], 'x');  // Preallocate needed size
      set_out_date(std::move(tmp_str));
      }
      //std::string tmp_str4(sizes[idx++], 'x');  // Preallocate needed size
      //set_out_date(std::move(tmp_str4));
      // store pointer in the pointers list
      ptrs.push_back(reinterpret_cast<uint8_t*>(const_cast<char*>(out_date().c_str())));
      return idx;
  }
  size_t allocate_from_sizes(std::vector<size_t> &sizes, size_t idx = 0) {
      idx++;
      {
        std::string tmp_str(sizes[idx++], 'x');  // Preallocate needed size
        set_hotel_id(std::move(tmp_str));
      }
      {
        std::string tmp_str(sizes[idx++], 'x');  // Preallocate needed size
        set_customer_name(std::move(tmp_str));
      }
      {
        std::string tmp_str(sizes[idx++], 'x');  // Preallocate needed size
        set_in_date(std::move(tmp_str));
      }
      {
        std::string tmp_str(sizes[idx++], 'x');  // Preallocate needed size
        set_out_date(std::move(tmp_str));
      }
      return idx;
  }

  // accessors -------------------------------------------------------
  enum : int {
    kHotelIdFieldNumber = 1,
    kCustomerNameFieldNumber = 2,
    kInDateFieldNumber = 3,
    kOutDateFieldNumber = 4,
    kNumberFieldNumber = 5,
  };
  // string hotel_id = 1;
  void clear_hotel_id() ;
  const std::string& hotel_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_hotel_id(Arg_&& arg, Args_... args);
  std::string* mutable_hotel_id();
  PROTOBUF_NODISCARD std::string* release_hotel_id();
  void set_allocated_hotel_id(std::string* value);

  private:
  const std::string& _internal_hotel_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hotel_id(
      const std::string& value);
  std::string* _internal_mutable_hotel_id();

  public:
  // string customer_name = 2;
  void clear_customer_name() ;
  const std::string& customer_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_customer_name(Arg_&& arg, Args_... args);
  std::string* mutable_customer_name();
  PROTOBUF_NODISCARD std::string* release_customer_name();
  void set_allocated_customer_name(std::string* value);

  private:
  const std::string& _internal_customer_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_customer_name(
      const std::string& value);
  std::string* _internal_mutable_customer_name();

  public:
  // string in_date = 3;
  void clear_in_date() ;
  const std::string& in_date() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_in_date(Arg_&& arg, Args_... args);
  std::string* mutable_in_date();
  PROTOBUF_NODISCARD std::string* release_in_date();
  void set_allocated_in_date(std::string* value);

  private:
  const std::string& _internal_in_date() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_in_date(
      const std::string& value);
  std::string* _internal_mutable_in_date();

  public:
  // string out_date = 4;
  void clear_out_date() ;
  const std::string& out_date() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_out_date(Arg_&& arg, Args_... args);
  std::string* mutable_out_date();
  PROTOBUF_NODISCARD std::string* release_out_date();
  void set_allocated_out_date(std::string* value);

  private:
  const std::string& _internal_out_date() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_out_date(
      const std::string& value);
  std::string* _internal_mutable_out_date();

  public:
  // int64 number = 5;
  void clear_number() ;
  ::int64_t number() const;
  void set_number(::int64_t value);

  private:
  ::int64_t _internal_number() const;
  void _internal_set_number(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:hotelreservation.Reservation)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 0,
      73, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_Reservation_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr hotel_id_;
    ::google::protobuf::internal::ArenaStringPtr customer_name_;
    ::google::protobuf::internal::ArenaStringPtr in_date_;
    ::google::protobuf::internal::ArenaStringPtr out_date_;
    ::int64_t number_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_hotel_5freservation_2eproto;
};
// -------------------------------------------------------------------

class RecommendRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:hotelreservation.RecommendRequest) */ {
 public:
  inline RecommendRequest() : RecommendRequest(nullptr) {}
  ~RecommendRequest() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RecommendRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline RecommendRequest(const RecommendRequest& from) : RecommendRequest(nullptr, from) {}
  inline RecommendRequest(RecommendRequest&& from) noexcept
      : RecommendRequest(nullptr, std::move(from)) {}
  inline RecommendRequest& operator=(const RecommendRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RecommendRequest& operator=(RecommendRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RecommendRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RecommendRequest* internal_default_instance() {
    return reinterpret_cast<const RecommendRequest*>(
        &_RecommendRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 11;
  friend void swap(RecommendRequest& a, RecommendRequest& b) { a.Swap(&b); }
  inline void Swap(RecommendRequest* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RecommendRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RecommendRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<RecommendRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RecommendRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RecommendRequest& from) { RecommendRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RecommendRequest* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "hotelreservation.RecommendRequest"; }

 protected:
  explicit RecommendRequest(::google::protobuf::Arena* arena);
  RecommendRequest(::google::protobuf::Arena* arena, const RecommendRequest& from);
  RecommendRequest(::google::protobuf::Arena* arena, RecommendRequest&& from) noexcept
      : RecommendRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // schemas for IAA/DSA ---------------------------------------------
  void generate_schema(std::vector<std::tuple<uint8_t*, size_t>> &schema) {
      auto start_addr = reinterpret_cast<uint8_t*>(&_impl_.lat_);
      auto end_addr = reinterpret_cast<uint8_t*>(&_impl_.lon_);
      schema.push_back(std::make_tuple(start_addr, end_addr - start_addr + sizeof(lon())));
      schema.push_back(std::make_tuple(reinterpret_cast<uint8_t*>(const_cast<char*>(require().c_str())), require().size()));
      schema.push_back(std::make_tuple(reinterpret_cast<uint8_t*>(const_cast<char*>(locale().c_str())), locale().size()));
  }
  void generate_seperated_schema(std::vector<uint8_t*> &ptrs_list, std::vector<size_t> &sizes_list) {
      auto start_addr = reinterpret_cast<uint8_t*>(&_impl_.lat_);
      auto end_addr = reinterpret_cast<uint8_t*>(&_impl_.lon_);
      ptrs_list.push_back(start_addr);
      sizes_list.push_back(end_addr - start_addr + sizeof(lon()));
      ptrs_list.push_back(reinterpret_cast<uint8_t*>(const_cast<char*>(require().c_str())));
      sizes_list.push_back(require().size());
      ptrs_list.push_back(reinterpret_cast<uint8_t*>(const_cast<char*>(locale().c_str())));
      sizes_list.push_back(locale().size());
  }
  void generate_scatter_ptrs(std::vector<uint8_t*> &ptrs) {
      auto start_addr = reinterpret_cast<uint8_t*>(&_impl_.lat_);
      //auto end_addr = reinterpret_cast<uint8_t*>(&_impl_.lon_);
      ptrs.push_back(start_addr);
      ptrs.push_back(reinterpret_cast<uint8_t*>(const_cast<char*>(require().c_str())));
      ptrs.push_back(reinterpret_cast<uint8_t*>(const_cast<char*>(locale().c_str())));
  }
  void generate_scatter_sizes(std::vector<size_t> &sizes) {
      auto start_addr = reinterpret_cast<uint8_t*>(&_impl_.lat_);
      auto end_addr = reinterpret_cast<uint8_t*>(&_impl_.lon_);
      sizes.push_back(end_addr - start_addr + sizeof(lon()));
      sizes.push_back(require().size());
      sizes.push_back(locale().size());
  }
  size_t generate_scatter_ptrs_and_allocate_from_sizes(std::vector<uint8_t*> &ptrs, std::vector<size_t> &sizes, size_t idx = 0) {
      idx++;
      // only primitive field pointers
      auto start_addr = reinterpret_cast<uint8_t*>(&_impl_.lat_);
      //auto end_addr = reinterpret_cast<uint8_t*>(&_impl_.lon_);
      ptrs.push_back(start_addr);
      // non-primitive field pointers + allocation
      // allocate
      {
      std::string tmp_str(sizes[idx++], 'x');  // Preallocate needed size
      set_require(std::move(tmp_str));
      }
      //std::string tmp_str1(sizes[idx++], 'x');  // Preallocate needed size
      //set_require(std::move(tmp_str1));
      // store pointer in the pointers list
      ptrs.push_back(reinterpret_cast<uint8_t*>(const_cast<char*>(require().c_str())));
      // allocate
      {
      std::string tmp_str(sizes[idx++], 'x');  // Preallocate needed size
      set_locale(std::move(tmp_str));
      }
      //std::string tmp_str2(sizes[idx++], 'x');  // Preallocate needed size
      //set_locale(std::move(tmp_str2));
      // store pointer in the pointers list
      ptrs.push_back(reinterpret_cast<uint8_t*>(const_cast<char*>(locale().c_str())));
      return idx;
  }
  size_t allocate_from_sizes(std::vector<size_t> &sizes, size_t idx = 0) {
      idx++;
      {
        std::string tmp_str(sizes[idx++], 'x');  // Preallocate needed size
        set_require(std::move(tmp_str));
      }
      {
        std::string tmp_str(sizes[idx++], 'x');  // Preallocate needed size
        set_locale(std::move(tmp_str));
      }
      return idx;
  }

  // accessors -------------------------------------------------------
  enum : int {
    kRequireFieldNumber = 3,
    kLocaleFieldNumber = 4,
    kLatFieldNumber = 1,
    kLonFieldNumber = 2,
  };
  // string require = 3;
  void clear_require() ;
  const std::string& require() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_require(Arg_&& arg, Args_... args);
  std::string* mutable_require();
  PROTOBUF_NODISCARD std::string* release_require();
  void set_allocated_require(std::string* value);

  private:
  const std::string& _internal_require() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_require(
      const std::string& value);
  std::string* _internal_mutable_require();

  public:
  // string locale = 4;
  void clear_locale() ;
  const std::string& locale() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_locale(Arg_&& arg, Args_... args);
  std::string* mutable_locale();
  PROTOBUF_NODISCARD std::string* release_locale();
  void set_allocated_locale(std::string* value);

  private:
  const std::string& _internal_locale() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_locale(
      const std::string& value);
  std::string* _internal_mutable_locale();

  public:
  // double lat = 1;
  void clear_lat() ;
  double lat() const;
  void set_lat(double value);

  private:
  double _internal_lat() const;
  void _internal_set_lat(double value);

  public:
  // double lon = 2;
  void clear_lon() ;
  double lon() const;
  void set_lon(double value);

  private:
  double _internal_lon() const;
  void _internal_set_lon(double value);

  public:
  // @@protoc_insertion_point(class_scope:hotelreservation.RecommendRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 0,
      55, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_RecommendRequest_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr require_;
    ::google::protobuf::internal::ArenaStringPtr locale_;
    double lat_;
    double lon_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_hotel_5freservation_2eproto;
};
// -------------------------------------------------------------------

class Point final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:hotelreservation.Point) */ {
 public:
  inline Point() : Point(nullptr) {}
  ~Point() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Point(
      ::google::protobuf::internal::ConstantInitialized);

  inline Point(const Point& from) : Point(nullptr, from) {}
  inline Point(Point&& from) noexcept
      : Point(nullptr, std::move(from)) {}
  inline Point& operator=(const Point& from) {
    CopyFrom(from);
    return *this;
  }
  inline Point& operator=(Point&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Point& default_instance() {
    return *internal_default_instance();
  }
  static inline const Point* internal_default_instance() {
    return reinterpret_cast<const Point*>(
        &_Point_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(Point& a, Point& b) { a.Swap(&b); }
  inline void Swap(Point* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Point* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Point* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<Point>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Point& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Point& from) { Point::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Point* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "hotelreservation.Point"; }

 protected:
  explicit Point(::google::protobuf::Arena* arena);
  Point(::google::protobuf::Arena* arena, const Point& from);
  Point(::google::protobuf::Arena* arena, Point&& from) noexcept
      : Point(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // schemas for IAA/DSA ---------------------------------------------
  void generate_schema(std::vector<std::tuple<uint8_t*, size_t>> &schema) {
      auto start_addr = reinterpret_cast<uint8_t*>(&_impl_.plat_);
      auto end_addr = reinterpret_cast<uint8_t*>(&_impl_.plon_);
      schema.push_back(std::make_tuple(start_addr, end_addr - start_addr + sizeof(plon())));
      schema.push_back(std::make_tuple(reinterpret_cast<uint8_t*>(const_cast<char*>(pid().c_str())), pid().size()));
  }
  void generate_seperated_schema(std::vector<uint8_t*> &ptrs_list, std::vector<size_t> &sizes_list) {
      auto start_addr = reinterpret_cast<uint8_t*>(&_impl_.plat_);
      auto end_addr = reinterpret_cast<uint8_t*>(&_impl_.plon_);
      ptrs_list.push_back(start_addr);
      sizes_list.push_back(end_addr - start_addr + sizeof(plon()));
      ptrs_list.push_back(reinterpret_cast<uint8_t*>(const_cast<char*>(pid().c_str())));
      sizes_list.push_back(pid().size());
  }
  void generate_scatter_ptrs(std::vector<uint8_t*> &ptrs) {
      auto start_addr = reinterpret_cast<uint8_t*>(&_impl_.plat_);
      //auto end_addr = reinterpret_cast<uint8_t*>(&_impl_.plon_);
      ptrs.push_back(start_addr);
      ptrs.push_back(reinterpret_cast<uint8_t*>(const_cast<char*>(pid().c_str())));
  }
  void generate_scatter_sizes(std::vector<size_t> &sizes) {
      auto start_addr = reinterpret_cast<uint8_t*>(&_impl_.plat_);
      auto end_addr = reinterpret_cast<uint8_t*>(&_impl_.plon_);
      sizes.push_back(end_addr - start_addr + sizeof(plon()));
      sizes.push_back(pid().size());
  }
  size_t generate_scatter_ptrs_and_allocate_from_sizes(std::vector<uint8_t*> &ptrs, std::vector<size_t> &sizes, size_t idx = 0) {
      idx++;
      // only primitive field pointers
      auto start_addr = reinterpret_cast<uint8_t*>(&_impl_.plat_);
      //auto end_addr = reinterpret_cast<uint8_t*>(&_impl_.plon_);
      ptrs.push_back(start_addr);
      // non-primitive field pointers + allocation
      // allocate
      {
      std::string tmp_str(sizes[idx++], 'x');  // Preallocate needed size
      set_pid(std::move(tmp_str));
      }
      //std::string tmp_str1(sizes[idx++], 'x');  // Preallocate needed size
      //set_pid(std::move(tmp_str1));
      // store pointer in the pointers list
      ptrs.push_back(reinterpret_cast<uint8_t*>(const_cast<char*>(pid().c_str())));
      return idx;
  }
  size_t allocate_from_sizes(std::vector<size_t> &sizes, size_t idx = 0) {
      idx++;
      {
        std::string tmp_str(sizes[idx++], 'x');  // Preallocate needed size
        set_pid(std::move(tmp_str));
      }
      return idx;
  }

  // accessors -------------------------------------------------------
  enum : int {
    kPidFieldNumber = 1,
    kPlatFieldNumber = 2,
    kPlonFieldNumber = 3,
  };
  // string pid = 1;
  void clear_pid() ;
  const std::string& pid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_pid(Arg_&& arg, Args_... args);
  std::string* mutable_pid();
  PROTOBUF_NODISCARD std::string* release_pid();
  void set_allocated_pid(std::string* value);

  private:
  const std::string& _internal_pid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pid(
      const std::string& value);
  std::string* _internal_mutable_pid();

  public:
  // double plat = 2;
  void clear_plat() ;
  double plat() const;
  void set_plat(double value);

  private:
  double _internal_plat() const;
  void _internal_set_plat(double value);

  public:
  // double plon = 3;
  void clear_plon() ;
  double plon() const;
  void set_plon(double value);

  private:
  double _internal_plon() const;
  void _internal_set_plon(double value);

  public:
  // @@protoc_insertion_point(class_scope:hotelreservation.Point)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      34, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_Point_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr pid_;
    double plat_;
    double plon_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_hotel_5freservation_2eproto;
};
// -------------------------------------------------------------------

class NearbyResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:hotelreservation.NearbyResponse) */ {
 public:
  inline NearbyResponse() : NearbyResponse(nullptr) {}
  ~NearbyResponse() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR NearbyResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline NearbyResponse(const NearbyResponse& from) : NearbyResponse(nullptr, from) {}
  inline NearbyResponse(NearbyResponse&& from) noexcept
      : NearbyResponse(nullptr, std::move(from)) {}
  inline NearbyResponse& operator=(const NearbyResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline NearbyResponse& operator=(NearbyResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NearbyResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const NearbyResponse* internal_default_instance() {
    return reinterpret_cast<const NearbyResponse*>(
        &_NearbyResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 18;
  friend void swap(NearbyResponse& a, NearbyResponse& b) { a.Swap(&b); }
  inline void Swap(NearbyResponse* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NearbyResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NearbyResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<NearbyResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NearbyResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const NearbyResponse& from) { NearbyResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(NearbyResponse* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "hotelreservation.NearbyResponse"; }

 protected:
  explicit NearbyResponse(::google::protobuf::Arena* arena);
  NearbyResponse(::google::protobuf::Arena* arena, const NearbyResponse& from);
  NearbyResponse(::google::protobuf::Arena* arena, NearbyResponse&& from) noexcept
      : NearbyResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // schemas for IAA/DSA ---------------------------------------------
  void generate_schema(std::vector<std::tuple<uint8_t*, size_t>> &schema) {
      for (int i = 0; i < hotel_ids_size(); ++i) {
        schema.push_back(std::make_tuple(reinterpret_cast<uint8_t*>(const_cast<char*>(hotel_ids(i).data())), hotel_ids(i).size()));
      }
  }
  void generate_seperated_schema(std::vector<uint8_t*> &ptrs_list, std::vector<size_t> &sizes_list) {
      ptrs_list.push_back(nullptr);
      sizes_list.push_back(0);
      ptrs_list.push_back(nullptr);
      sizes_list.push_back(hotel_ids().size());
      for (int i = 0; i < hotel_ids_size(); ++i) {
        ptrs_list.push_back(reinterpret_cast<uint8_t*>(const_cast<char*>(hotel_ids(i).c_str())));
        sizes_list.push_back(hotel_ids(i).size());
      }
  }
  void generate_scatter_ptrs(std::vector<uint8_t*> &ptrs) {
      ptrs.push_back(nullptr);
      ptrs.push_back(nullptr);
      for (int i = 0; i < hotel_ids_size(); ++i) {
        ptrs.push_back(reinterpret_cast<uint8_t*>(const_cast<char*>(hotel_ids(i).c_str())));
      }
  }
  void generate_scatter_sizes(std::vector<size_t> &sizes) {
      sizes.push_back(0);
      sizes.push_back(hotel_ids().size());
      for (int i = 0; i < hotel_ids_size(); ++i) {
        sizes.push_back(hotel_ids(i).size());
      }
  }
  size_t generate_scatter_ptrs_and_allocate_from_sizes(std::vector<uint8_t*> &ptrs, std::vector<size_t> &sizes, size_t idx = 0) {
      idx++;
      // only primitive field pointers
      ptrs.push_back(nullptr);
      // non-primitive field pointers + allocation
      return idx;
  }
  size_t allocate_from_sizes(std::vector<size_t> &sizes, size_t idx = 0) {
      idx++;
      size_t num_hotel_ids_entries = sizes[idx++];
      for (size_t i = 0; i < num_hotel_ids_entries; ++i) {
          std::string tmp_str(sizes[idx++], 'x');  // Preallocate needed size
          add_hotel_ids(std::move(tmp_str));
      }
      return idx;
  }

  // accessors -------------------------------------------------------
  enum : int {
    kHotelIdsFieldNumber = 1,
  };
  // repeated string hotel_ids = 1;
  int hotel_ids_size() const;
  private:
  int _internal_hotel_ids_size() const;

  public:
  void clear_hotel_ids() ;
  const std::string& hotel_ids(int index) const;
  std::string* mutable_hotel_ids(int index);
  void set_hotel_ids(int index, const std::string& value);
  void set_hotel_ids(int index, std::string&& value);
  void set_hotel_ids(int index, const char* value);
  void set_hotel_ids(int index, const char* value, std::size_t size);
  void set_hotel_ids(int index, absl::string_view value);
  std::string* add_hotel_ids();
  void add_hotel_ids(const std::string& value);
  void add_hotel_ids(std::string&& value);
  void add_hotel_ids(const char* value);
  void add_hotel_ids(const char* value, std::size_t size);
  void add_hotel_ids(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& hotel_ids() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_hotel_ids();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_hotel_ids() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_hotel_ids();

  public:
  // @@protoc_insertion_point(class_scope:hotelreservation.NearbyResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      49, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_NearbyResponse_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField<std::string> hotel_ids_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_hotel_5freservation_2eproto;
};
// -------------------------------------------------------------------

class NearbyRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:hotelreservation.NearbyRequest) */ {
 public:
  inline NearbyRequest() : NearbyRequest(nullptr) {}
  ~NearbyRequest() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR NearbyRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline NearbyRequest(const NearbyRequest& from) : NearbyRequest(nullptr, from) {}
  inline NearbyRequest(NearbyRequest&& from) noexcept
      : NearbyRequest(nullptr, std::move(from)) {}
  inline NearbyRequest& operator=(const NearbyRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline NearbyRequest& operator=(NearbyRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NearbyRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const NearbyRequest* internal_default_instance() {
    return reinterpret_cast<const NearbyRequest*>(
        &_NearbyRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 17;
  friend void swap(NearbyRequest& a, NearbyRequest& b) { a.Swap(&b); }
  inline void Swap(NearbyRequest* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NearbyRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NearbyRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<NearbyRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NearbyRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const NearbyRequest& from) { NearbyRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(NearbyRequest* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "hotelreservation.NearbyRequest"; }

 protected:
  explicit NearbyRequest(::google::protobuf::Arena* arena);
  NearbyRequest(::google::protobuf::Arena* arena, const NearbyRequest& from);
  NearbyRequest(::google::protobuf::Arena* arena, NearbyRequest&& from) noexcept
      : NearbyRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // schemas for IAA/DSA ---------------------------------------------
  void generate_schema(std::vector<std::tuple<uint8_t*, size_t>> &schema) {
      auto start_addr = reinterpret_cast<uint8_t*>(&_impl_.lat_);
      auto end_addr = reinterpret_cast<uint8_t*>(&_impl_.lon_);
      schema.push_back(std::make_tuple(start_addr, end_addr - start_addr + sizeof(lon())));
  }
  void generate_seperated_schema(std::vector<uint8_t*> &ptrs_list, std::vector<size_t> &sizes_list) {
      auto start_addr = reinterpret_cast<uint8_t*>(&_impl_.lat_);
      auto end_addr = reinterpret_cast<uint8_t*>(&_impl_.lon_);
      ptrs_list.push_back(start_addr);
      sizes_list.push_back(end_addr - start_addr + sizeof(lon()));
  }
  void generate_scatter_ptrs(std::vector<uint8_t*> &ptrs) {
      auto start_addr = reinterpret_cast<uint8_t*>(&_impl_.lat_);
      //auto end_addr = reinterpret_cast<uint8_t*>(&_impl_.lon_);
      ptrs.push_back(start_addr);
  }
  void generate_scatter_sizes(std::vector<size_t> &sizes) {
      auto start_addr = reinterpret_cast<uint8_t*>(&_impl_.lat_);
      auto end_addr = reinterpret_cast<uint8_t*>(&_impl_.lon_);
      sizes.push_back(end_addr - start_addr + sizeof(lon()));
  }
  size_t generate_scatter_ptrs_and_allocate_from_sizes(std::vector<uint8_t*> &ptrs, std::vector<size_t> &sizes, size_t idx = 0) {
      idx++;
      // only primitive field pointers
      auto start_addr = reinterpret_cast<uint8_t*>(&_impl_.lat_);
      //auto end_addr = reinterpret_cast<uint8_t*>(&_impl_.lon_);
      ptrs.push_back(start_addr);
      // non-primitive field pointers + allocation
      return idx;
  }
  size_t allocate_from_sizes(std::vector<size_t> &sizes, size_t idx = 0) {
      idx++;
      return idx;
  }

  // accessors -------------------------------------------------------
  enum : int {
    kLatFieldNumber = 1,
    kLonFieldNumber = 2,
  };
  // double lat = 1;
  void clear_lat() ;
  double lat() const;
  void set_lat(double value);

  private:
  double _internal_lat() const;
  void _internal_set_lat(double value);

  public:
  // double lon = 2;
  void clear_lon() ;
  double lon() const;
  void set_lon(double value);

  private:
  double _internal_lon() const;
  void _internal_set_lon(double value);

  public:
  // @@protoc_insertion_point(class_scope:hotelreservation.NearbyRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_NearbyRequest_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    double lat_;
    double lon_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_hotel_5freservation_2eproto;
};
// -------------------------------------------------------------------

class HotelNumber final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:hotelreservation.HotelNumber) */ {
 public:
  inline HotelNumber() : HotelNumber(nullptr) {}
  ~HotelNumber() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR HotelNumber(
      ::google::protobuf::internal::ConstantInitialized);

  inline HotelNumber(const HotelNumber& from) : HotelNumber(nullptr, from) {}
  inline HotelNumber(HotelNumber&& from) noexcept
      : HotelNumber(nullptr, std::move(from)) {}
  inline HotelNumber& operator=(const HotelNumber& from) {
    CopyFrom(from);
    return *this;
  }
  inline HotelNumber& operator=(HotelNumber&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HotelNumber& default_instance() {
    return *internal_default_instance();
  }
  static inline const HotelNumber* internal_default_instance() {
    return reinterpret_cast<const HotelNumber*>(
        &_HotelNumber_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 5;
  friend void swap(HotelNumber& a, HotelNumber& b) { a.Swap(&b); }
  inline void Swap(HotelNumber* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HotelNumber* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HotelNumber* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<HotelNumber>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const HotelNumber& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const HotelNumber& from) { HotelNumber::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(HotelNumber* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "hotelreservation.HotelNumber"; }

 protected:
  explicit HotelNumber(::google::protobuf::Arena* arena);
  HotelNumber(::google::protobuf::Arena* arena, const HotelNumber& from);
  HotelNumber(::google::protobuf::Arena* arena, HotelNumber&& from) noexcept
      : HotelNumber(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // schemas for IAA/DSA ---------------------------------------------
  void generate_schema(std::vector<std::tuple<uint8_t*, size_t>> &schema) {
      auto start_addr = reinterpret_cast<uint8_t*>(&_impl_.number_);
      auto end_addr = reinterpret_cast<uint8_t*>(&_impl_.number_);
      schema.push_back(std::make_tuple(start_addr, end_addr - start_addr + sizeof(number())));
      schema.push_back(std::make_tuple(reinterpret_cast<uint8_t*>(const_cast<char*>(hotel_id().c_str())), hotel_id().size()));
  }
  void generate_seperated_schema(std::vector<uint8_t*> &ptrs_list, std::vector<size_t> &sizes_list) {
      auto start_addr = reinterpret_cast<uint8_t*>(&_impl_.number_);
      auto end_addr = reinterpret_cast<uint8_t*>(&_impl_.number_);
      ptrs_list.push_back(start_addr);
      sizes_list.push_back(end_addr - start_addr + sizeof(number()));
      ptrs_list.push_back(reinterpret_cast<uint8_t*>(const_cast<char*>(hotel_id().c_str())));
      sizes_list.push_back(hotel_id().size());
  }
  void generate_scatter_ptrs(std::vector<uint8_t*> &ptrs) {
      auto start_addr = reinterpret_cast<uint8_t*>(&_impl_.number_);
      //auto end_addr = reinterpret_cast<uint8_t*>(&_impl_.number_);
      ptrs.push_back(start_addr);
      ptrs.push_back(reinterpret_cast<uint8_t*>(const_cast<char*>(hotel_id().c_str())));
  }
  void generate_scatter_sizes(std::vector<size_t> &sizes) {
      auto start_addr = reinterpret_cast<uint8_t*>(&_impl_.number_);
      auto end_addr = reinterpret_cast<uint8_t*>(&_impl_.number_);
      sizes.push_back(end_addr - start_addr + sizeof(number()));
      sizes.push_back(hotel_id().size());
  }
  size_t generate_scatter_ptrs_and_allocate_from_sizes(std::vector<uint8_t*> &ptrs, std::vector<size_t> &sizes, size_t idx = 0) {
      idx++;
      // only primitive field pointers
      auto start_addr = reinterpret_cast<uint8_t*>(&_impl_.number_);
      //auto end_addr = reinterpret_cast<uint8_t*>(&_impl_.number_);
      ptrs.push_back(start_addr);
      // non-primitive field pointers + allocation
      // allocate
      {
      std::string tmp_str(sizes[idx++], 'x');  // Preallocate needed size
      set_hotel_id(std::move(tmp_str));
      }
      //std::string tmp_str1(sizes[idx++], 'x');  // Preallocate needed size
      //set_hotel_id(std::move(tmp_str1));
      // store pointer in the pointers list
      ptrs.push_back(reinterpret_cast<uint8_t*>(const_cast<char*>(hotel_id().c_str())));
      return idx;
  }
  size_t allocate_from_sizes(std::vector<size_t> &sizes, size_t idx = 0) {
      idx++;
      {
        std::string tmp_str(sizes[idx++], 'x');  // Preallocate needed size
        set_hotel_id(std::move(tmp_str));
      }
      return idx;
  }

  // accessors -------------------------------------------------------
  enum : int {
    kHotelIdFieldNumber = 1,
    kNumberFieldNumber = 2,
  };
  // string hotel_id = 1;
  void clear_hotel_id() ;
  const std::string& hotel_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_hotel_id(Arg_&& arg, Args_... args);
  std::string* mutable_hotel_id();
  PROTOBUF_NODISCARD std::string* release_hotel_id();
  void set_allocated_hotel_id(std::string* value);

  private:
  const std::string& _internal_hotel_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hotel_id(
      const std::string& value);
  std::string* _internal_mutable_hotel_id();

  public:
  // int64 number = 2;
  void clear_number() ;
  ::int64_t number() const;
  void set_number(::int64_t value);

  private:
  ::int64_t _internal_number() const;
  void _internal_set_number(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:hotelreservation.HotelNumber)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      45, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_HotelNumber_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr hotel_id_;
    ::int64_t number_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_hotel_5freservation_2eproto;
};
// -------------------------------------------------------------------

class Hotel final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:hotelreservation.Hotel) */ {
 public:
  inline Hotel() : Hotel(nullptr) {}
  ~Hotel() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Hotel(
      ::google::protobuf::internal::ConstantInitialized);

  inline Hotel(const Hotel& from) : Hotel(nullptr, from) {}
  inline Hotel(Hotel&& from) noexcept
      : Hotel(nullptr, std::move(from)) {}
  inline Hotel& operator=(const Hotel& from) {
    CopyFrom(from);
    return *this;
  }
  inline Hotel& operator=(Hotel&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Hotel& default_instance() {
    return *internal_default_instance();
  }
  static inline const Hotel* internal_default_instance() {
    return reinterpret_cast<const Hotel*>(
        &_Hotel_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 6;
  friend void swap(Hotel& a, Hotel& b) { a.Swap(&b); }
  inline void Swap(Hotel* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Hotel* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Hotel* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<Hotel>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Hotel& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Hotel& from) { Hotel::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Hotel* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "hotelreservation.Hotel"; }

 protected:
  explicit Hotel(::google::protobuf::Arena* arena);
  Hotel(::google::protobuf::Arena* arena, const Hotel& from);
  Hotel(::google::protobuf::Arena* arena, Hotel&& from) noexcept
      : Hotel(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // schemas for IAA/DSA ---------------------------------------------
  void generate_schema(std::vector<std::tuple<uint8_t*, size_t>> &schema) {
      auto start_addr = reinterpret_cast<uint8_t*>(&_impl_.h_lat_);
      auto end_addr = reinterpret_cast<uint8_t*>(&_impl_.h_price_);
      schema.push_back(std::make_tuple(start_addr, end_addr - start_addr + sizeof(h_price())));
      schema.push_back(std::make_tuple(reinterpret_cast<uint8_t*>(const_cast<char*>(h_id().c_str())), h_id().size()));
  }
  void generate_seperated_schema(std::vector<uint8_t*> &ptrs_list, std::vector<size_t> &sizes_list) {
      auto start_addr = reinterpret_cast<uint8_t*>(&_impl_.h_lat_);
      auto end_addr = reinterpret_cast<uint8_t*>(&_impl_.h_price_);
      ptrs_list.push_back(start_addr);
      sizes_list.push_back(end_addr - start_addr + sizeof(h_price()));
      ptrs_list.push_back(reinterpret_cast<uint8_t*>(const_cast<char*>(h_id().c_str())));
      sizes_list.push_back(h_id().size());
  }
  void generate_scatter_ptrs(std::vector<uint8_t*> &ptrs) {
      auto start_addr = reinterpret_cast<uint8_t*>(&_impl_.h_lat_);
      //auto end_addr = reinterpret_cast<uint8_t*>(&_impl_.h_price_);
      ptrs.push_back(start_addr);
      ptrs.push_back(reinterpret_cast<uint8_t*>(const_cast<char*>(h_id().c_str())));
  }
  void generate_scatter_sizes(std::vector<size_t> &sizes) {
      auto start_addr = reinterpret_cast<uint8_t*>(&_impl_.h_lat_);
      auto end_addr = reinterpret_cast<uint8_t*>(&_impl_.h_price_);
      sizes.push_back(end_addr - start_addr + sizeof(h_price()));
      sizes.push_back(h_id().size());
  }
  size_t generate_scatter_ptrs_and_allocate_from_sizes(std::vector<uint8_t*> &ptrs, std::vector<size_t> &sizes, size_t idx = 0) {
      idx++;
      // only primitive field pointers
      auto start_addr = reinterpret_cast<uint8_t*>(&_impl_.h_lat_);
      //auto end_addr = reinterpret_cast<uint8_t*>(&_impl_.h_price_);
      ptrs.push_back(start_addr);
      // non-primitive field pointers + allocation
      // allocate
      {
      std::string tmp_str(sizes[idx++], 'x');  // Preallocate needed size
      set_h_id(std::move(tmp_str));
      }
      //std::string tmp_str1(sizes[idx++], 'x');  // Preallocate needed size
      //set_h_id(std::move(tmp_str1));
      // store pointer in the pointers list
      ptrs.push_back(reinterpret_cast<uint8_t*>(const_cast<char*>(h_id().c_str())));
      return idx;
  }
  size_t allocate_from_sizes(std::vector<size_t> &sizes, size_t idx = 0) {
      idx++;
      {
        std::string tmp_str(sizes[idx++], 'x');  // Preallocate needed size
        set_h_id(std::move(tmp_str));
      }
      return idx;
  }

  // accessors -------------------------------------------------------
  enum : int {
    kHIdFieldNumber = 1,
    kHLatFieldNumber = 2,
    kHLonFieldNumber = 3,
    kHRateFieldNumber = 4,
    kHPriceFieldNumber = 5,
  };
  // string h_id = 1;
  void clear_h_id() ;
  const std::string& h_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_h_id(Arg_&& arg, Args_... args);
  std::string* mutable_h_id();
  PROTOBUF_NODISCARD std::string* release_h_id();
  void set_allocated_h_id(std::string* value);

  private:
  const std::string& _internal_h_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_h_id(
      const std::string& value);
  std::string* _internal_mutable_h_id();

  public:
  // double h_lat = 2;
  void clear_h_lat() ;
  double h_lat() const;
  void set_h_lat(double value);

  private:
  double _internal_h_lat() const;
  void _internal_set_h_lat(double value);

  public:
  // double h_lon = 3;
  void clear_h_lon() ;
  double h_lon() const;
  void set_h_lon(double value);

  private:
  double _internal_h_lon() const;
  void _internal_set_h_lon(double value);

  public:
  // double h_rate = 4;
  void clear_h_rate() ;
  double h_rate() const;
  void set_h_rate(double value);

  private:
  double _internal_h_rate() const;
  void _internal_set_h_rate(double value);

  public:
  // double h_price = 5;
  void clear_h_price() ;
  double h_price() const;
  void set_h_price(double value);

  private:
  double _internal_h_price() const;
  void _internal_set_h_price(double value);

  public:
  // @@protoc_insertion_point(class_scope:hotelreservation.Hotel)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 0,
      35, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_Hotel_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr h_id_;
    double h_lat_;
    double h_lon_;
    double h_rate_;
    double h_price_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_hotel_5freservation_2eproto;
};
// -------------------------------------------------------------------

class GetRatesRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:hotelreservation.GetRatesRequest) */ {
 public:
  inline GetRatesRequest() : GetRatesRequest(nullptr) {}
  ~GetRatesRequest() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GetRatesRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline GetRatesRequest(const GetRatesRequest& from) : GetRatesRequest(nullptr, from) {}
  inline GetRatesRequest(GetRatesRequest&& from) noexcept
      : GetRatesRequest(nullptr, std::move(from)) {}
  inline GetRatesRequest& operator=(const GetRatesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetRatesRequest& operator=(GetRatesRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetRatesRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetRatesRequest* internal_default_instance() {
    return reinterpret_cast<const GetRatesRequest*>(
        &_GetRatesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 21;
  friend void swap(GetRatesRequest& a, GetRatesRequest& b) { a.Swap(&b); }
  inline void Swap(GetRatesRequest* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetRatesRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetRatesRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<GetRatesRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetRatesRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GetRatesRequest& from) { GetRatesRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GetRatesRequest* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "hotelreservation.GetRatesRequest"; }

 protected:
  explicit GetRatesRequest(::google::protobuf::Arena* arena);
  GetRatesRequest(::google::protobuf::Arena* arena, const GetRatesRequest& from);
  GetRatesRequest(::google::protobuf::Arena* arena, GetRatesRequest&& from) noexcept
      : GetRatesRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // schemas for IAA/DSA ---------------------------------------------
  void generate_schema(std::vector<std::tuple<uint8_t*, size_t>> &schema) {
      for (int i = 0; i < hotel_ids_size(); ++i) {
        schema.push_back(std::make_tuple(reinterpret_cast<uint8_t*>(const_cast<char*>(hotel_ids(i).data())), hotel_ids(i).size()));
      }
      schema.push_back(std::make_tuple(reinterpret_cast<uint8_t*>(const_cast<char*>(in_date().c_str())), in_date().size()));
      schema.push_back(std::make_tuple(reinterpret_cast<uint8_t*>(const_cast<char*>(out_date().c_str())), out_date().size()));
  }
  void generate_seperated_schema(std::vector<uint8_t*> &ptrs_list, std::vector<size_t> &sizes_list) {
      ptrs_list.push_back(nullptr);
      sizes_list.push_back(0);
      ptrs_list.push_back(nullptr);
      sizes_list.push_back(hotel_ids().size());
      for (int i = 0; i < hotel_ids_size(); ++i) {
        ptrs_list.push_back(reinterpret_cast<uint8_t*>(const_cast<char*>(hotel_ids(i).c_str())));
        sizes_list.push_back(hotel_ids(i).size());
      }
      ptrs_list.push_back(reinterpret_cast<uint8_t*>(const_cast<char*>(in_date().c_str())));
      sizes_list.push_back(in_date().size());
      ptrs_list.push_back(reinterpret_cast<uint8_t*>(const_cast<char*>(out_date().c_str())));
      sizes_list.push_back(out_date().size());
  }
  void generate_scatter_ptrs(std::vector<uint8_t*> &ptrs) {
      ptrs.push_back(nullptr);
      ptrs.push_back(nullptr);
      for (int i = 0; i < hotel_ids_size(); ++i) {
        ptrs.push_back(reinterpret_cast<uint8_t*>(const_cast<char*>(hotel_ids(i).c_str())));
      }
      ptrs.push_back(reinterpret_cast<uint8_t*>(const_cast<char*>(in_date().c_str())));
      ptrs.push_back(reinterpret_cast<uint8_t*>(const_cast<char*>(out_date().c_str())));
  }
  void generate_scatter_sizes(std::vector<size_t> &sizes) {
      sizes.push_back(0);
      sizes.push_back(hotel_ids().size());
      for (int i = 0; i < hotel_ids_size(); ++i) {
        sizes.push_back(hotel_ids(i).size());
      }
      sizes.push_back(in_date().size());
      sizes.push_back(out_date().size());
  }
  size_t generate_scatter_ptrs_and_allocate_from_sizes(std::vector<uint8_t*> &ptrs, std::vector<size_t> &sizes, size_t idx = 0) {
      idx++;
      // only primitive field pointers
      ptrs.push_back(nullptr);
      // non-primitive field pointers + allocation
      // allocate
      {
      std::string tmp_str(sizes[idx++], 'x');  // Preallocate needed size
      set_in_date(std::move(tmp_str));
      }
      //std::string tmp_str1(sizes[idx++], 'x');  // Preallocate needed size
      //set_in_date(std::move(tmp_str1));
      // store pointer in the pointers list
      ptrs.push_back(reinterpret_cast<uint8_t*>(const_cast<char*>(in_date().c_str())));
      // allocate
      {
      std::string tmp_str(sizes[idx++], 'x');  // Preallocate needed size
      set_out_date(std::move(tmp_str));
      }
      //std::string tmp_str2(sizes[idx++], 'x');  // Preallocate needed size
      //set_out_date(std::move(tmp_str2));
      // store pointer in the pointers list
      ptrs.push_back(reinterpret_cast<uint8_t*>(const_cast<char*>(out_date().c_str())));
      return idx;
  }
  size_t allocate_from_sizes(std::vector<size_t> &sizes, size_t idx = 0) {
      idx++;
      size_t num_hotel_ids_entries = sizes[idx++];
      for (size_t i = 0; i < num_hotel_ids_entries; ++i) {
          std::string tmp_str(sizes[idx++], 'x');  // Preallocate needed size
          add_hotel_ids(std::move(tmp_str));
      }
      {
        std::string tmp_str(sizes[idx++], 'x');  // Preallocate needed size
        set_in_date(std::move(tmp_str));
      }
      {
        std::string tmp_str(sizes[idx++], 'x');  // Preallocate needed size
        set_out_date(std::move(tmp_str));
      }
      return idx;
  }

  // accessors -------------------------------------------------------
  enum : int {
    kHotelIdsFieldNumber = 1,
    kInDateFieldNumber = 2,
    kOutDateFieldNumber = 3,
  };
  // repeated string hotel_ids = 1;
  int hotel_ids_size() const;
  private:
  int _internal_hotel_ids_size() const;

  public:
  void clear_hotel_ids() ;
  const std::string& hotel_ids(int index) const;
  std::string* mutable_hotel_ids(int index);
  void set_hotel_ids(int index, const std::string& value);
  void set_hotel_ids(int index, std::string&& value);
  void set_hotel_ids(int index, const char* value);
  void set_hotel_ids(int index, const char* value, std::size_t size);
  void set_hotel_ids(int index, absl::string_view value);
  std::string* add_hotel_ids();
  void add_hotel_ids(const std::string& value);
  void add_hotel_ids(std::string&& value);
  void add_hotel_ids(const char* value);
  void add_hotel_ids(const char* value, std::size_t size);
  void add_hotel_ids(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& hotel_ids() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_hotel_ids();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_hotel_ids() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_hotel_ids();

  public:
  // string in_date = 2;
  void clear_in_date() ;
  const std::string& in_date() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_in_date(Arg_&& arg, Args_... args);
  std::string* mutable_in_date();
  PROTOBUF_NODISCARD std::string* release_in_date();
  void set_allocated_in_date(std::string* value);

  private:
  const std::string& _internal_in_date() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_in_date(
      const std::string& value);
  std::string* _internal_mutable_in_date();

  public:
  // string out_date = 3;
  void clear_out_date() ;
  const std::string& out_date() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_out_date(Arg_&& arg, Args_... args);
  std::string* mutable_out_date();
  PROTOBUF_NODISCARD std::string* release_out_date();
  void set_allocated_out_date(std::string* value);

  private:
  const std::string& _internal_out_date() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_out_date(
      const std::string& value);
  std::string* _internal_mutable_out_date();

  public:
  // @@protoc_insertion_point(class_scope:hotelreservation.GetRatesRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      65, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_GetRatesRequest_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField<std::string> hotel_ids_;
    ::google::protobuf::internal::ArenaStringPtr in_date_;
    ::google::protobuf::internal::ArenaStringPtr out_date_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_hotel_5freservation_2eproto;
};
// -------------------------------------------------------------------

class GetProfilesRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:hotelreservation.GetProfilesRequest) */ {
 public:
  inline GetProfilesRequest() : GetProfilesRequest(nullptr) {}
  ~GetProfilesRequest() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GetProfilesRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline GetProfilesRequest(const GetProfilesRequest& from) : GetProfilesRequest(nullptr, from) {}
  inline GetProfilesRequest(GetProfilesRequest&& from) noexcept
      : GetProfilesRequest(nullptr, std::move(from)) {}
  inline GetProfilesRequest& operator=(const GetProfilesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetProfilesRequest& operator=(GetProfilesRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetProfilesRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetProfilesRequest* internal_default_instance() {
    return reinterpret_cast<const GetProfilesRequest*>(
        &_GetProfilesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 19;
  friend void swap(GetProfilesRequest& a, GetProfilesRequest& b) { a.Swap(&b); }
  inline void Swap(GetProfilesRequest* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetProfilesRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetProfilesRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<GetProfilesRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetProfilesRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GetProfilesRequest& from) { GetProfilesRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GetProfilesRequest* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "hotelreservation.GetProfilesRequest"; }

 protected:
  explicit GetProfilesRequest(::google::protobuf::Arena* arena);
  GetProfilesRequest(::google::protobuf::Arena* arena, const GetProfilesRequest& from);
  GetProfilesRequest(::google::protobuf::Arena* arena, GetProfilesRequest&& from) noexcept
      : GetProfilesRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // schemas for IAA/DSA ---------------------------------------------
  void generate_schema(std::vector<std::tuple<uint8_t*, size_t>> &schema) {
      for (int i = 0; i < hotel_ids_size(); ++i) {
        schema.push_back(std::make_tuple(reinterpret_cast<uint8_t*>(const_cast<char*>(hotel_ids(i).data())), hotel_ids(i).size()));
      }
      schema.push_back(std::make_tuple(reinterpret_cast<uint8_t*>(const_cast<char*>(locale().c_str())), locale().size()));
  }
  void generate_seperated_schema(std::vector<uint8_t*> &ptrs_list, std::vector<size_t> &sizes_list) {
      ptrs_list.push_back(nullptr);
      sizes_list.push_back(0);
      ptrs_list.push_back(nullptr);
      sizes_list.push_back(hotel_ids().size());
      for (int i = 0; i < hotel_ids_size(); ++i) {
        ptrs_list.push_back(reinterpret_cast<uint8_t*>(const_cast<char*>(hotel_ids(i).c_str())));
        sizes_list.push_back(hotel_ids(i).size());
      }
      ptrs_list.push_back(reinterpret_cast<uint8_t*>(const_cast<char*>(locale().c_str())));
      sizes_list.push_back(locale().size());
  }
  void generate_scatter_ptrs(std::vector<uint8_t*> &ptrs) {
      ptrs.push_back(nullptr);
      ptrs.push_back(nullptr);
      for (int i = 0; i < hotel_ids_size(); ++i) {
        ptrs.push_back(reinterpret_cast<uint8_t*>(const_cast<char*>(hotel_ids(i).c_str())));
      }
      ptrs.push_back(reinterpret_cast<uint8_t*>(const_cast<char*>(locale().c_str())));
  }
  void generate_scatter_sizes(std::vector<size_t> &sizes) {
      sizes.push_back(0);
      sizes.push_back(hotel_ids().size());
      for (int i = 0; i < hotel_ids_size(); ++i) {
        sizes.push_back(hotel_ids(i).size());
      }
      sizes.push_back(locale().size());
  }
  size_t generate_scatter_ptrs_and_allocate_from_sizes(std::vector<uint8_t*> &ptrs, std::vector<size_t> &sizes, size_t idx = 0) {
      idx++;
      // only primitive field pointers
      ptrs.push_back(nullptr);
      // non-primitive field pointers + allocation
      // allocate
      {
      std::string tmp_str(sizes[idx++], 'x');  // Preallocate needed size
      set_locale(std::move(tmp_str));
      }
      //std::string tmp_str1(sizes[idx++], 'x');  // Preallocate needed size
      //set_locale(std::move(tmp_str1));
      // store pointer in the pointers list
      ptrs.push_back(reinterpret_cast<uint8_t*>(const_cast<char*>(locale().c_str())));
      return idx;
  }
  size_t allocate_from_sizes(std::vector<size_t> &sizes, size_t idx = 0) {
      idx++;
      size_t num_hotel_ids_entries = sizes[idx++];
      for (size_t i = 0; i < num_hotel_ids_entries; ++i) {
          std::string tmp_str(sizes[idx++], 'x');  // Preallocate needed size
          add_hotel_ids(std::move(tmp_str));
      }
      {
        std::string tmp_str(sizes[idx++], 'x');  // Preallocate needed size
        set_locale(std::move(tmp_str));
      }
      return idx;
  }

  // accessors -------------------------------------------------------
  enum : int {
    kHotelIdsFieldNumber = 1,
    kLocaleFieldNumber = 2,
  };
  // repeated string hotel_ids = 1;
  int hotel_ids_size() const;
  private:
  int _internal_hotel_ids_size() const;

  public:
  void clear_hotel_ids() ;
  const std::string& hotel_ids(int index) const;
  std::string* mutable_hotel_ids(int index);
  void set_hotel_ids(int index, const std::string& value);
  void set_hotel_ids(int index, std::string&& value);
  void set_hotel_ids(int index, const char* value);
  void set_hotel_ids(int index, const char* value, std::size_t size);
  void set_hotel_ids(int index, absl::string_view value);
  std::string* add_hotel_ids();
  void add_hotel_ids(const std::string& value);
  void add_hotel_ids(std::string&& value);
  void add_hotel_ids(const char* value);
  void add_hotel_ids(const char* value, std::size_t size);
  void add_hotel_ids(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& hotel_ids() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_hotel_ids();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_hotel_ids() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_hotel_ids();

  public:
  // string locale = 2;
  void clear_locale() ;
  const std::string& locale() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_locale(Arg_&& arg, Args_... args);
  std::string* mutable_locale();
  PROTOBUF_NODISCARD std::string* release_locale();
  void set_allocated_locale(std::string* value);

  private:
  const std::string& _internal_locale() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_locale(
      const std::string& value);
  std::string* _internal_mutable_locale();

  public:
  // @@protoc_insertion_point(class_scope:hotelreservation.GetProfilesRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      59, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_GetProfilesRequest_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField<std::string> hotel_ids_;
    ::google::protobuf::internal::ArenaStringPtr locale_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_hotel_5freservation_2eproto;
};
// -------------------------------------------------------------------

class CheckUserResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:hotelreservation.CheckUserResponse) */ {
 public:
  inline CheckUserResponse() : CheckUserResponse(nullptr) {}
  ~CheckUserResponse() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CheckUserResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline CheckUserResponse(const CheckUserResponse& from) : CheckUserResponse(nullptr, from) {}
  inline CheckUserResponse(CheckUserResponse&& from) noexcept
      : CheckUserResponse(nullptr, std::move(from)) {}
  inline CheckUserResponse& operator=(const CheckUserResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CheckUserResponse& operator=(CheckUserResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CheckUserResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CheckUserResponse* internal_default_instance() {
    return reinterpret_cast<const CheckUserResponse*>(
        &_CheckUserResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 24;
  friend void swap(CheckUserResponse& a, CheckUserResponse& b) { a.Swap(&b); }
  inline void Swap(CheckUserResponse* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CheckUserResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CheckUserResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<CheckUserResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CheckUserResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CheckUserResponse& from) { CheckUserResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CheckUserResponse* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "hotelreservation.CheckUserResponse"; }

 protected:
  explicit CheckUserResponse(::google::protobuf::Arena* arena);
  CheckUserResponse(::google::protobuf::Arena* arena, const CheckUserResponse& from);
  CheckUserResponse(::google::protobuf::Arena* arena, CheckUserResponse&& from) noexcept
      : CheckUserResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // schemas for IAA/DSA ---------------------------------------------
  void generate_schema(std::vector<std::tuple<uint8_t*, size_t>> &schema) {
      auto start_addr = reinterpret_cast<uint8_t*>(&_impl_.exists_);
      auto end_addr = reinterpret_cast<uint8_t*>(&_impl_.exists_);
      schema.push_back(std::make_tuple(start_addr, end_addr - start_addr + sizeof(exists())));
  }
  void generate_seperated_schema(std::vector<uint8_t*> &ptrs_list, std::vector<size_t> &sizes_list) {
      auto start_addr = reinterpret_cast<uint8_t*>(&_impl_.exists_);
      auto end_addr = reinterpret_cast<uint8_t*>(&_impl_.exists_);
      ptrs_list.push_back(start_addr);
      sizes_list.push_back(end_addr - start_addr + sizeof(exists()));
  }
  void generate_scatter_ptrs(std::vector<uint8_t*> &ptrs) {
      auto start_addr = reinterpret_cast<uint8_t*>(&_impl_.exists_);
      //auto end_addr = reinterpret_cast<uint8_t*>(&_impl_.exists_);
      ptrs.push_back(start_addr);
  }
  void generate_scatter_sizes(std::vector<size_t> &sizes) {
      auto start_addr = reinterpret_cast<uint8_t*>(&_impl_.exists_);
      auto end_addr = reinterpret_cast<uint8_t*>(&_impl_.exists_);
      sizes.push_back(end_addr - start_addr + sizeof(exists()));
  }
  size_t generate_scatter_ptrs_and_allocate_from_sizes(std::vector<uint8_t*> &ptrs, std::vector<size_t> &sizes, size_t idx = 0) {
      idx++;
      // only primitive field pointers
      auto start_addr = reinterpret_cast<uint8_t*>(&_impl_.exists_);
      //auto end_addr = reinterpret_cast<uint8_t*>(&_impl_.exists_);
      ptrs.push_back(start_addr);
      // non-primitive field pointers + allocation
      return idx;
  }
  size_t allocate_from_sizes(std::vector<size_t> &sizes, size_t idx = 0) {
      idx++;
      return idx;
  }

  // accessors -------------------------------------------------------
  enum : int {
    kExistsFieldNumber = 1,
  };
  // bool exists = 1;
  void clear_exists() ;
  bool exists() const;
  void set_exists(bool value);

  private:
  bool _internal_exists() const;
  void _internal_set_exists(bool value);

  public:
  // @@protoc_insertion_point(class_scope:hotelreservation.CheckUserResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_CheckUserResponse_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    bool exists_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_hotel_5freservation_2eproto;
};
// -------------------------------------------------------------------

class CheckUserRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:hotelreservation.CheckUserRequest) */ {
 public:
  inline CheckUserRequest() : CheckUserRequest(nullptr) {}
  ~CheckUserRequest() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CheckUserRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline CheckUserRequest(const CheckUserRequest& from) : CheckUserRequest(nullptr, from) {}
  inline CheckUserRequest(CheckUserRequest&& from) noexcept
      : CheckUserRequest(nullptr, std::move(from)) {}
  inline CheckUserRequest& operator=(const CheckUserRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CheckUserRequest& operator=(CheckUserRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CheckUserRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CheckUserRequest* internal_default_instance() {
    return reinterpret_cast<const CheckUserRequest*>(
        &_CheckUserRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 23;
  friend void swap(CheckUserRequest& a, CheckUserRequest& b) { a.Swap(&b); }
  inline void Swap(CheckUserRequest* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CheckUserRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CheckUserRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<CheckUserRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CheckUserRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CheckUserRequest& from) { CheckUserRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CheckUserRequest* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "hotelreservation.CheckUserRequest"; }

 protected:
  explicit CheckUserRequest(::google::protobuf::Arena* arena);
  CheckUserRequest(::google::protobuf::Arena* arena, const CheckUserRequest& from);
  CheckUserRequest(::google::protobuf::Arena* arena, CheckUserRequest&& from) noexcept
      : CheckUserRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // schemas for IAA/DSA ---------------------------------------------
  void generate_schema(std::vector<std::tuple<uint8_t*, size_t>> &schema) {
      schema.push_back(std::make_tuple(reinterpret_cast<uint8_t*>(const_cast<char*>(username().c_str())), username().size()));
      schema.push_back(std::make_tuple(reinterpret_cast<uint8_t*>(const_cast<char*>(password().c_str())), password().size()));
  }
  void generate_seperated_schema(std::vector<uint8_t*> &ptrs_list, std::vector<size_t> &sizes_list) {
      ptrs_list.push_back(nullptr);
      sizes_list.push_back(0);
      ptrs_list.push_back(reinterpret_cast<uint8_t*>(const_cast<char*>(username().c_str())));
      sizes_list.push_back(username().size());
      ptrs_list.push_back(reinterpret_cast<uint8_t*>(const_cast<char*>(password().c_str())));
      sizes_list.push_back(password().size());
  }
  void generate_scatter_ptrs(std::vector<uint8_t*> &ptrs) {
      ptrs.push_back(nullptr);
      ptrs.push_back(reinterpret_cast<uint8_t*>(const_cast<char*>(username().c_str())));
      ptrs.push_back(reinterpret_cast<uint8_t*>(const_cast<char*>(password().c_str())));
  }
  void generate_scatter_sizes(std::vector<size_t> &sizes) {
      sizes.push_back(0);
      sizes.push_back(username().size());
      sizes.push_back(password().size());
  }
  size_t generate_scatter_ptrs_and_allocate_from_sizes(std::vector<uint8_t*> &ptrs, std::vector<size_t> &sizes, size_t idx = 0) {
      idx++;
      // only primitive field pointers
      ptrs.push_back(nullptr);
      // non-primitive field pointers + allocation
      // allocate
      {
      std::string tmp_str(sizes[idx++], 'x');  // Preallocate needed size
      set_username(std::move(tmp_str));
      }
      //std::string tmp_str1(sizes[idx++], 'x');  // Preallocate needed size
      //set_username(std::move(tmp_str1));
      // store pointer in the pointers list
      ptrs.push_back(reinterpret_cast<uint8_t*>(const_cast<char*>(username().c_str())));
      // allocate
      {
      std::string tmp_str(sizes[idx++], 'x');  // Preallocate needed size
      set_password(std::move(tmp_str));
      }
      //std::string tmp_str2(sizes[idx++], 'x');  // Preallocate needed size
      //set_password(std::move(tmp_str2));
      // store pointer in the pointers list
      ptrs.push_back(reinterpret_cast<uint8_t*>(const_cast<char*>(password().c_str())));
      return idx;
  }
  size_t allocate_from_sizes(std::vector<size_t> &sizes, size_t idx = 0) {
      idx++;
      {
        std::string tmp_str(sizes[idx++], 'x');  // Preallocate needed size
        set_username(std::move(tmp_str));
      }
      {
        std::string tmp_str(sizes[idx++], 'x');  // Preallocate needed size
        set_password(std::move(tmp_str));
      }
      return idx;
  }

  // accessors -------------------------------------------------------
  enum : int {
    kUsernameFieldNumber = 1,
    kPasswordFieldNumber = 2,
  };
  // string username = 1;
  void clear_username() ;
  const std::string& username() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_username(Arg_&& arg, Args_... args);
  std::string* mutable_username();
  PROTOBUF_NODISCARD std::string* release_username();
  void set_allocated_username(std::string* value);

  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(
      const std::string& value);
  std::string* _internal_mutable_username();

  public:
  // string password = 2;
  void clear_password() ;
  const std::string& password() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_password(Arg_&& arg, Args_... args);
  std::string* mutable_password();
  PROTOBUF_NODISCARD std::string* release_password();
  void set_allocated_password(std::string* value);

  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(
      const std::string& value);
  std::string* _internal_mutable_password();

  public:
  // @@protoc_insertion_point(class_scope:hotelreservation.CheckUserRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      58, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_CheckUserRequest_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr username_;
    ::google::protobuf::internal::ArenaStringPtr password_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_hotel_5freservation_2eproto;
};
// -------------------------------------------------------------------

class Address final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:hotelreservation.Address) */ {
 public:
  inline Address() : Address(nullptr) {}
  ~Address() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Address(
      ::google::protobuf::internal::ConstantInitialized);

  inline Address(const Address& from) : Address(nullptr, from) {}
  inline Address(Address&& from) noexcept
      : Address(nullptr, std::move(from)) {}
  inline Address& operator=(const Address& from) {
    CopyFrom(from);
    return *this;
  }
  inline Address& operator=(Address&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Address& default_instance() {
    return *internal_default_instance();
  }
  static inline const Address* internal_default_instance() {
    return reinterpret_cast<const Address*>(
        &_Address_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 7;
  friend void swap(Address& a, Address& b) { a.Swap(&b); }
  inline void Swap(Address* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Address* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Address* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<Address>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Address& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Address& from) { Address::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Address* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "hotelreservation.Address"; }

 protected:
  explicit Address(::google::protobuf::Arena* arena);
  Address(::google::protobuf::Arena* arena, const Address& from);
  Address(::google::protobuf::Arena* arena, Address&& from) noexcept
      : Address(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // schemas for IAA/DSA ---------------------------------------------
  void generate_schema(std::vector<std::tuple<uint8_t*, size_t>> &schema) {
      auto start_addr = reinterpret_cast<uint8_t*>(&_impl_.lat_);
      auto end_addr = reinterpret_cast<uint8_t*>(&_impl_.lon_);
      schema.push_back(std::make_tuple(start_addr, end_addr - start_addr + sizeof(lon())));
      schema.push_back(std::make_tuple(reinterpret_cast<uint8_t*>(const_cast<char*>(street_number().c_str())), street_number().size()));
      schema.push_back(std::make_tuple(reinterpret_cast<uint8_t*>(const_cast<char*>(street_name().c_str())), street_name().size()));
      schema.push_back(std::make_tuple(reinterpret_cast<uint8_t*>(const_cast<char*>(city().c_str())), city().size()));
      schema.push_back(std::make_tuple(reinterpret_cast<uint8_t*>(const_cast<char*>(state().c_str())), state().size()));
      schema.push_back(std::make_tuple(reinterpret_cast<uint8_t*>(const_cast<char*>(country().c_str())), country().size()));
      schema.push_back(std::make_tuple(reinterpret_cast<uint8_t*>(const_cast<char*>(postal_code().c_str())), postal_code().size()));
  }
  void generate_seperated_schema(std::vector<uint8_t*> &ptrs_list, std::vector<size_t> &sizes_list) {
      auto start_addr = reinterpret_cast<uint8_t*>(&_impl_.lat_);
      auto end_addr = reinterpret_cast<uint8_t*>(&_impl_.lon_);
      ptrs_list.push_back(start_addr);
      sizes_list.push_back(end_addr - start_addr + sizeof(lon()));
      ptrs_list.push_back(reinterpret_cast<uint8_t*>(const_cast<char*>(street_number().c_str())));
      sizes_list.push_back(street_number().size());
      ptrs_list.push_back(reinterpret_cast<uint8_t*>(const_cast<char*>(street_name().c_str())));
      sizes_list.push_back(street_name().size());
      ptrs_list.push_back(reinterpret_cast<uint8_t*>(const_cast<char*>(city().c_str())));
      sizes_list.push_back(city().size());
      ptrs_list.push_back(reinterpret_cast<uint8_t*>(const_cast<char*>(state().c_str())));
      sizes_list.push_back(state().size());
      ptrs_list.push_back(reinterpret_cast<uint8_t*>(const_cast<char*>(country().c_str())));
      sizes_list.push_back(country().size());
      ptrs_list.push_back(reinterpret_cast<uint8_t*>(const_cast<char*>(postal_code().c_str())));
      sizes_list.push_back(postal_code().size());
  }
  void generate_scatter_ptrs(std::vector<uint8_t*> &ptrs) {
      auto start_addr = reinterpret_cast<uint8_t*>(&_impl_.lat_);
      //auto end_addr = reinterpret_cast<uint8_t*>(&_impl_.lon_);
      ptrs.push_back(start_addr);
      ptrs.push_back(reinterpret_cast<uint8_t*>(const_cast<char*>(street_number().c_str())));
      ptrs.push_back(reinterpret_cast<uint8_t*>(const_cast<char*>(street_name().c_str())));
      ptrs.push_back(reinterpret_cast<uint8_t*>(const_cast<char*>(city().c_str())));
      ptrs.push_back(reinterpret_cast<uint8_t*>(const_cast<char*>(state().c_str())));
      ptrs.push_back(reinterpret_cast<uint8_t*>(const_cast<char*>(country().c_str())));
      ptrs.push_back(reinterpret_cast<uint8_t*>(const_cast<char*>(postal_code().c_str())));
  }
  void generate_scatter_sizes(std::vector<size_t> &sizes) {
      auto start_addr = reinterpret_cast<uint8_t*>(&_impl_.lat_);
      auto end_addr = reinterpret_cast<uint8_t*>(&_impl_.lon_);
      sizes.push_back(end_addr - start_addr + sizeof(lon()));
      sizes.push_back(street_number().size());
      sizes.push_back(street_name().size());
      sizes.push_back(city().size());
      sizes.push_back(state().size());
      sizes.push_back(country().size());
      sizes.push_back(postal_code().size());
  }
  size_t generate_scatter_ptrs_and_allocate_from_sizes(std::vector<uint8_t*> &ptrs, std::vector<size_t> &sizes, size_t idx = 0) {
      idx++;
      // only primitive field pointers
      auto start_addr = reinterpret_cast<uint8_t*>(&_impl_.lat_);
      //auto end_addr = reinterpret_cast<uint8_t*>(&_impl_.lon_);
      ptrs.push_back(start_addr);
      // non-primitive field pointers + allocation
      // allocate
      {
      std::string tmp_str(sizes[idx++], 'x');  // Preallocate needed size
      set_street_number(std::move(tmp_str));
      }
      //std::string tmp_str1(sizes[idx++], 'x');  // Preallocate needed size
      //set_street_number(std::move(tmp_str1));
      // store pointer in the pointers list
      ptrs.push_back(reinterpret_cast<uint8_t*>(const_cast<char*>(street_number().c_str())));
      // allocate
      {
      std::string tmp_str(sizes[idx++], 'x');  // Preallocate needed size
      set_street_name(std::move(tmp_str));
      }
      //std::string tmp_str2(sizes[idx++], 'x');  // Preallocate needed size
      //set_street_name(std::move(tmp_str2));
      // store pointer in the pointers list
      ptrs.push_back(reinterpret_cast<uint8_t*>(const_cast<char*>(street_name().c_str())));
      // allocate
      {
      std::string tmp_str(sizes[idx++], 'x');  // Preallocate needed size
      set_city(std::move(tmp_str));
      }
      //std::string tmp_str3(sizes[idx++], 'x');  // Preallocate needed size
      //set_city(std::move(tmp_str3));
      // store pointer in the pointers list
      ptrs.push_back(reinterpret_cast<uint8_t*>(const_cast<char*>(city().c_str())));
      // allocate
      {
      std::string tmp_str(sizes[idx++], 'x');  // Preallocate needed size
      set_state(std::move(tmp_str));
      }
      //std::string tmp_str4(sizes[idx++], 'x');  // Preallocate needed size
      //set_state(std::move(tmp_str4));
      // store pointer in the pointers list
      ptrs.push_back(reinterpret_cast<uint8_t*>(const_cast<char*>(state().c_str())));
      // allocate
      {
      std::string tmp_str(sizes[idx++], 'x');  // Preallocate needed size
      set_country(std::move(tmp_str));
      }
      //std::string tmp_str5(sizes[idx++], 'x');  // Preallocate needed size
      //set_country(std::move(tmp_str5));
      // store pointer in the pointers list
      ptrs.push_back(reinterpret_cast<uint8_t*>(const_cast<char*>(country().c_str())));
      // allocate
      {
      std::string tmp_str(sizes[idx++], 'x');  // Preallocate needed size
      set_postal_code(std::move(tmp_str));
      }
      //std::string tmp_str6(sizes[idx++], 'x');  // Preallocate needed size
      //set_postal_code(std::move(tmp_str6));
      // store pointer in the pointers list
      ptrs.push_back(reinterpret_cast<uint8_t*>(const_cast<char*>(postal_code().c_str())));
      return idx;
  }
  size_t allocate_from_sizes(std::vector<size_t> &sizes, size_t idx = 0) {
      idx++;
      {
        std::string tmp_str(sizes[idx++], 'x');  // Preallocate needed size
        set_street_number(std::move(tmp_str));
      }
      {
        std::string tmp_str(sizes[idx++], 'x');  // Preallocate needed size
        set_street_name(std::move(tmp_str));
      }
      {
        std::string tmp_str(sizes[idx++], 'x');  // Preallocate needed size
        set_city(std::move(tmp_str));
      }
      {
        std::string tmp_str(sizes[idx++], 'x');  // Preallocate needed size
        set_state(std::move(tmp_str));
      }
      {
        std::string tmp_str(sizes[idx++], 'x');  // Preallocate needed size
        set_country(std::move(tmp_str));
      }
      {
        std::string tmp_str(sizes[idx++], 'x');  // Preallocate needed size
        set_postal_code(std::move(tmp_str));
      }
      return idx;
  }

  // accessors -------------------------------------------------------
  enum : int {
    kStreetNumberFieldNumber = 1,
    kStreetNameFieldNumber = 2,
    kCityFieldNumber = 3,
    kStateFieldNumber = 4,
    kCountryFieldNumber = 5,
    kPostalCodeFieldNumber = 6,
    kLatFieldNumber = 7,
    kLonFieldNumber = 8,
  };
  // string street_number = 1;
  void clear_street_number() ;
  const std::string& street_number() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_street_number(Arg_&& arg, Args_... args);
  std::string* mutable_street_number();
  PROTOBUF_NODISCARD std::string* release_street_number();
  void set_allocated_street_number(std::string* value);

  private:
  const std::string& _internal_street_number() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_street_number(
      const std::string& value);
  std::string* _internal_mutable_street_number();

  public:
  // string street_name = 2;
  void clear_street_name() ;
  const std::string& street_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_street_name(Arg_&& arg, Args_... args);
  std::string* mutable_street_name();
  PROTOBUF_NODISCARD std::string* release_street_name();
  void set_allocated_street_name(std::string* value);

  private:
  const std::string& _internal_street_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_street_name(
      const std::string& value);
  std::string* _internal_mutable_street_name();

  public:
  // string city = 3;
  void clear_city() ;
  const std::string& city() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_city(Arg_&& arg, Args_... args);
  std::string* mutable_city();
  PROTOBUF_NODISCARD std::string* release_city();
  void set_allocated_city(std::string* value);

  private:
  const std::string& _internal_city() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_city(
      const std::string& value);
  std::string* _internal_mutable_city();

  public:
  // string state = 4;
  void clear_state() ;
  const std::string& state() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_state(Arg_&& arg, Args_... args);
  std::string* mutable_state();
  PROTOBUF_NODISCARD std::string* release_state();
  void set_allocated_state(std::string* value);

  private:
  const std::string& _internal_state() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_state(
      const std::string& value);
  std::string* _internal_mutable_state();

  public:
  // string country = 5;
  void clear_country() ;
  const std::string& country() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_country(Arg_&& arg, Args_... args);
  std::string* mutable_country();
  PROTOBUF_NODISCARD std::string* release_country();
  void set_allocated_country(std::string* value);

  private:
  const std::string& _internal_country() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_country(
      const std::string& value);
  std::string* _internal_mutable_country();

  public:
  // string postal_code = 6;
  void clear_postal_code() ;
  const std::string& postal_code() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_postal_code(Arg_&& arg, Args_... args);
  std::string* mutable_postal_code();
  PROTOBUF_NODISCARD std::string* release_postal_code();
  void set_allocated_postal_code(std::string* value);

  private:
  const std::string& _internal_postal_code() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_postal_code(
      const std::string& value);
  std::string* _internal_mutable_postal_code();

  public:
  // double lat = 7;
  void clear_lat() ;
  double lat() const;
  void set_lat(double value);

  private:
  double _internal_lat() const;
  void _internal_set_lat(double value);

  public:
  // double lon = 8;
  void clear_lon() ;
  double lon() const;
  void set_lon(double value);

  private:
  double _internal_lon() const;
  void _internal_set_lon(double value);

  public:
  // @@protoc_insertion_point(class_scope:hotelreservation.Address)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 8, 0,
      92, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_Address_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr street_number_;
    ::google::protobuf::internal::ArenaStringPtr street_name_;
    ::google::protobuf::internal::ArenaStringPtr city_;
    ::google::protobuf::internal::ArenaStringPtr state_;
    ::google::protobuf::internal::ArenaStringPtr country_;
    ::google::protobuf::internal::ArenaStringPtr postal_code_;
    double lat_;
    double lon_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_hotel_5freservation_2eproto;
};
// -------------------------------------------------------------------

class RatePlan final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:hotelreservation.RatePlan) */ {
 public:
  inline RatePlan() : RatePlan(nullptr) {}
  ~RatePlan() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RatePlan(
      ::google::protobuf::internal::ConstantInitialized);

  inline RatePlan(const RatePlan& from) : RatePlan(nullptr, from) {}
  inline RatePlan(RatePlan&& from) noexcept
      : RatePlan(nullptr, std::move(from)) {}
  inline RatePlan& operator=(const RatePlan& from) {
    CopyFrom(from);
    return *this;
  }
  inline RatePlan& operator=(RatePlan&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RatePlan& default_instance() {
    return *internal_default_instance();
  }
  static inline const RatePlan* internal_default_instance() {
    return reinterpret_cast<const RatePlan*>(
        &_RatePlan_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(RatePlan& a, RatePlan& b) { a.Swap(&b); }
  inline void Swap(RatePlan* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RatePlan* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RatePlan* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<RatePlan>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RatePlan& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RatePlan& from) { RatePlan::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RatePlan* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "hotelreservation.RatePlan"; }

 protected:
  explicit RatePlan(::google::protobuf::Arena* arena);
  RatePlan(::google::protobuf::Arena* arena, const RatePlan& from);
  RatePlan(::google::protobuf::Arena* arena, RatePlan&& from) noexcept
      : RatePlan(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // schemas for IAA/DSA ---------------------------------------------
  void generate_schema(std::vector<std::tuple<uint8_t*, size_t>> &schema) {
      schema.push_back(std::make_tuple(reinterpret_cast<uint8_t*>(const_cast<char*>(hotel_id().c_str())), hotel_id().size()));
      schema.push_back(std::make_tuple(reinterpret_cast<uint8_t*>(const_cast<char*>(code().c_str())), code().size()));
      schema.push_back(std::make_tuple(reinterpret_cast<uint8_t*>(const_cast<char*>(in_date().c_str())), in_date().size()));
      schema.push_back(std::make_tuple(reinterpret_cast<uint8_t*>(const_cast<char*>(out_date().c_str())), out_date().size()));
      mutable_room_type()->generate_schema(schema);
  }
  void generate_seperated_schema(std::vector<uint8_t*> &ptrs_list, std::vector<size_t> &sizes_list) {
      ptrs_list.push_back(nullptr);
      sizes_list.push_back(0);
      ptrs_list.push_back(reinterpret_cast<uint8_t*>(const_cast<char*>(hotel_id().c_str())));
      sizes_list.push_back(hotel_id().size());
      ptrs_list.push_back(reinterpret_cast<uint8_t*>(const_cast<char*>(code().c_str())));
      sizes_list.push_back(code().size());
      ptrs_list.push_back(reinterpret_cast<uint8_t*>(const_cast<char*>(in_date().c_str())));
      sizes_list.push_back(in_date().size());
      ptrs_list.push_back(reinterpret_cast<uint8_t*>(const_cast<char*>(out_date().c_str())));
      sizes_list.push_back(out_date().size());
      mutable_room_type()->generate_seperated_schema(ptrs_list, sizes_list);
  }
  void generate_scatter_ptrs(std::vector<uint8_t*> &ptrs) {
      ptrs.push_back(nullptr);
      ptrs.push_back(reinterpret_cast<uint8_t*>(const_cast<char*>(hotel_id().c_str())));
      ptrs.push_back(reinterpret_cast<uint8_t*>(const_cast<char*>(code().c_str())));
      ptrs.push_back(reinterpret_cast<uint8_t*>(const_cast<char*>(in_date().c_str())));
      ptrs.push_back(reinterpret_cast<uint8_t*>(const_cast<char*>(out_date().c_str())));
      mutable_room_type()->generate_scatter_ptrs(ptrs);
  }
  void generate_scatter_sizes(std::vector<size_t> &sizes) {
      sizes.push_back(0);
      sizes.push_back(hotel_id().size());
      sizes.push_back(code().size());
      sizes.push_back(in_date().size());
      sizes.push_back(out_date().size());
      mutable_room_type()->generate_scatter_sizes(sizes);
  }
  size_t generate_scatter_ptrs_and_allocate_from_sizes(std::vector<uint8_t*> &ptrs, std::vector<size_t> &sizes, size_t idx = 0) {
      idx++;
      // only primitive field pointers
      ptrs.push_back(nullptr);
      // non-primitive field pointers + allocation
      // allocate
      {
      std::string tmp_str(sizes[idx++], 'x');  // Preallocate needed size
      set_hotel_id(std::move(tmp_str));
      }
      //std::string tmp_str1(sizes[idx++], 'x');  // Preallocate needed size
      //set_hotel_id(std::move(tmp_str1));
      // store pointer in the pointers list
      ptrs.push_back(reinterpret_cast<uint8_t*>(const_cast<char*>(hotel_id().c_str())));
      // allocate
      {
      std::string tmp_str(sizes[idx++], 'x');  // Preallocate needed size
      set_code(std::move(tmp_str));
      }
      //std::string tmp_str2(sizes[idx++], 'x');  // Preallocate needed size
      //set_code(std::move(tmp_str2));
      // store pointer in the pointers list
      ptrs.push_back(reinterpret_cast<uint8_t*>(const_cast<char*>(code().c_str())));
      // allocate
      {
      std::string tmp_str(sizes[idx++], 'x');  // Preallocate needed size
      set_in_date(std::move(tmp_str));
      }
      //std::string tmp_str3(sizes[idx++], 'x');  // Preallocate needed size
      //set_in_date(std::move(tmp_str3));
      // store pointer in the pointers list
      ptrs.push_back(reinterpret_cast<uint8_t*>(const_cast<char*>(in_date().c_str())));
      // allocate
      {
      std::string tmp_str(sizes[idx++], 'x');  // Preallocate needed size
      set_out_date(std::move(tmp_str));
      }
      //std::string tmp_str4(sizes[idx++], 'x');  // Preallocate needed size
      //set_out_date(std::move(tmp_str4));
      // store pointer in the pointers list
      ptrs.push_back(reinterpret_cast<uint8_t*>(const_cast<char*>(out_date().c_str())));
      idx = mutable_room_type()->generate_scatter_ptrs_and_allocate_from_sizes(ptrs, sizes, idx); 
      return idx;
  }
  size_t allocate_from_sizes(std::vector<size_t> &sizes, size_t idx = 0) {
      idx++;
      {
        std::string tmp_str(sizes[idx++], 'x');  // Preallocate needed size
        set_hotel_id(std::move(tmp_str));
      }
      {
        std::string tmp_str(sizes[idx++], 'x');  // Preallocate needed size
        set_code(std::move(tmp_str));
      }
      {
        std::string tmp_str(sizes[idx++], 'x');  // Preallocate needed size
        set_in_date(std::move(tmp_str));
      }
      {
        std::string tmp_str(sizes[idx++], 'x');  // Preallocate needed size
        set_out_date(std::move(tmp_str));
      }
      idx = mutable_room_type()->allocate_from_sizes(sizes, idx); 
      return idx;
  }

  // accessors -------------------------------------------------------
  enum : int {
    kHotelIdFieldNumber = 1,
    kCodeFieldNumber = 2,
    kInDateFieldNumber = 3,
    kOutDateFieldNumber = 4,
    kRoomTypeFieldNumber = 5,
  };
  // string hotel_id = 1;
  void clear_hotel_id() ;
  const std::string& hotel_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_hotel_id(Arg_&& arg, Args_... args);
  std::string* mutable_hotel_id();
  PROTOBUF_NODISCARD std::string* release_hotel_id();
  void set_allocated_hotel_id(std::string* value);

  private:
  const std::string& _internal_hotel_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hotel_id(
      const std::string& value);
  std::string* _internal_mutable_hotel_id();

  public:
  // string code = 2;
  void clear_code() ;
  const std::string& code() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_code(Arg_&& arg, Args_... args);
  std::string* mutable_code();
  PROTOBUF_NODISCARD std::string* release_code();
  void set_allocated_code(std::string* value);

  private:
  const std::string& _internal_code() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_code(
      const std::string& value);
  std::string* _internal_mutable_code();

  public:
  // string in_date = 3;
  void clear_in_date() ;
  const std::string& in_date() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_in_date(Arg_&& arg, Args_... args);
  std::string* mutable_in_date();
  PROTOBUF_NODISCARD std::string* release_in_date();
  void set_allocated_in_date(std::string* value);

  private:
  const std::string& _internal_in_date() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_in_date(
      const std::string& value);
  std::string* _internal_mutable_in_date();

  public:
  // string out_date = 4;
  void clear_out_date() ;
  const std::string& out_date() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_out_date(Arg_&& arg, Args_... args);
  std::string* mutable_out_date();
  PROTOBUF_NODISCARD std::string* release_out_date();
  void set_allocated_out_date(std::string* value);

  private:
  const std::string& _internal_out_date() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_out_date(
      const std::string& value);
  std::string* _internal_mutable_out_date();

  public:
  // .hotelreservation.RoomType room_type = 5;
  bool has_room_type() const;
  void clear_room_type() ;
  const ::hotelreservation::RoomType& room_type() const;
  PROTOBUF_NODISCARD ::hotelreservation::RoomType* release_room_type();
  ::hotelreservation::RoomType* mutable_room_type();
  void set_allocated_room_type(::hotelreservation::RoomType* value);
  void unsafe_arena_set_allocated_room_type(::hotelreservation::RoomType* value);
  ::hotelreservation::RoomType* unsafe_arena_release_room_type();

  private:
  const ::hotelreservation::RoomType& _internal_room_type() const;
  ::hotelreservation::RoomType* _internal_mutable_room_type();

  public:
  // @@protoc_insertion_point(class_scope:hotelreservation.RatePlan)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 1,
      61, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_RatePlan_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr hotel_id_;
    ::google::protobuf::internal::ArenaStringPtr code_;
    ::google::protobuf::internal::ArenaStringPtr in_date_;
    ::google::protobuf::internal::ArenaStringPtr out_date_;
    ::hotelreservation::RoomType* room_type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_hotel_5freservation_2eproto;
};
// -------------------------------------------------------------------

class HotelProfile final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:hotelreservation.HotelProfile) */ {
 public:
  inline HotelProfile() : HotelProfile(nullptr) {}
  ~HotelProfile() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR HotelProfile(
      ::google::protobuf::internal::ConstantInitialized);

  inline HotelProfile(const HotelProfile& from) : HotelProfile(nullptr, from) {}
  inline HotelProfile(HotelProfile&& from) noexcept
      : HotelProfile(nullptr, std::move(from)) {}
  inline HotelProfile& operator=(const HotelProfile& from) {
    CopyFrom(from);
    return *this;
  }
  inline HotelProfile& operator=(HotelProfile&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HotelProfile& default_instance() {
    return *internal_default_instance();
  }
  static inline const HotelProfile* internal_default_instance() {
    return reinterpret_cast<const HotelProfile*>(
        &_HotelProfile_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 8;
  friend void swap(HotelProfile& a, HotelProfile& b) { a.Swap(&b); }
  inline void Swap(HotelProfile* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HotelProfile* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HotelProfile* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<HotelProfile>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const HotelProfile& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const HotelProfile& from) { HotelProfile::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(HotelProfile* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "hotelreservation.HotelProfile"; }

 protected:
  explicit HotelProfile(::google::protobuf::Arena* arena);
  HotelProfile(::google::protobuf::Arena* arena, const HotelProfile& from);
  HotelProfile(::google::protobuf::Arena* arena, HotelProfile&& from) noexcept
      : HotelProfile(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // schemas for IAA/DSA ---------------------------------------------
  void generate_schema(std::vector<std::tuple<uint8_t*, size_t>> &schema) {
      schema.push_back(std::make_tuple(reinterpret_cast<uint8_t*>(const_cast<char*>(id().c_str())), id().size()));
      schema.push_back(std::make_tuple(reinterpret_cast<uint8_t*>(const_cast<char*>(name().c_str())), name().size()));
      schema.push_back(std::make_tuple(reinterpret_cast<uint8_t*>(const_cast<char*>(phone_number().c_str())), phone_number().size()));
      schema.push_back(std::make_tuple(reinterpret_cast<uint8_t*>(const_cast<char*>(description().c_str())), description().size()));
      mutable_address()->generate_schema(schema);
  }
  void generate_seperated_schema(std::vector<uint8_t*> &ptrs_list, std::vector<size_t> &sizes_list) {
      ptrs_list.push_back(nullptr);
      sizes_list.push_back(0);
      ptrs_list.push_back(reinterpret_cast<uint8_t*>(const_cast<char*>(id().c_str())));
      sizes_list.push_back(id().size());
      ptrs_list.push_back(reinterpret_cast<uint8_t*>(const_cast<char*>(name().c_str())));
      sizes_list.push_back(name().size());
      ptrs_list.push_back(reinterpret_cast<uint8_t*>(const_cast<char*>(phone_number().c_str())));
      sizes_list.push_back(phone_number().size());
      ptrs_list.push_back(reinterpret_cast<uint8_t*>(const_cast<char*>(description().c_str())));
      sizes_list.push_back(description().size());
      mutable_address()->generate_seperated_schema(ptrs_list, sizes_list);
  }
  void generate_scatter_ptrs(std::vector<uint8_t*> &ptrs) {
      ptrs.push_back(nullptr);
      ptrs.push_back(reinterpret_cast<uint8_t*>(const_cast<char*>(id().c_str())));
      ptrs.push_back(reinterpret_cast<uint8_t*>(const_cast<char*>(name().c_str())));
      ptrs.push_back(reinterpret_cast<uint8_t*>(const_cast<char*>(phone_number().c_str())));
      ptrs.push_back(reinterpret_cast<uint8_t*>(const_cast<char*>(description().c_str())));
      mutable_address()->generate_scatter_ptrs(ptrs);
  }
  void generate_scatter_sizes(std::vector<size_t> &sizes) {
      sizes.push_back(0);
      sizes.push_back(id().size());
      sizes.push_back(name().size());
      sizes.push_back(phone_number().size());
      sizes.push_back(description().size());
      mutable_address()->generate_scatter_sizes(sizes);
  }
  size_t generate_scatter_ptrs_and_allocate_from_sizes(std::vector<uint8_t*> &ptrs, std::vector<size_t> &sizes, size_t idx = 0) {
      idx++;
      // only primitive field pointers
      ptrs.push_back(nullptr);
      // non-primitive field pointers + allocation
      // allocate
      {
      std::string tmp_str(sizes[idx++], 'x');  // Preallocate needed size
      set_id(std::move(tmp_str));
      }
      //std::string tmp_str1(sizes[idx++], 'x');  // Preallocate needed size
      //set_id(std::move(tmp_str1));
      // store pointer in the pointers list
      ptrs.push_back(reinterpret_cast<uint8_t*>(const_cast<char*>(id().c_str())));
      // allocate
      {
      std::string tmp_str(sizes[idx++], 'x');  // Preallocate needed size
      set_name(std::move(tmp_str));
      }
      //std::string tmp_str2(sizes[idx++], 'x');  // Preallocate needed size
      //set_name(std::move(tmp_str2));
      // store pointer in the pointers list
      ptrs.push_back(reinterpret_cast<uint8_t*>(const_cast<char*>(name().c_str())));
      // allocate
      {
      std::string tmp_str(sizes[idx++], 'x');  // Preallocate needed size
      set_phone_number(std::move(tmp_str));
      }
      //std::string tmp_str3(sizes[idx++], 'x');  // Preallocate needed size
      //set_phone_number(std::move(tmp_str3));
      // store pointer in the pointers list
      ptrs.push_back(reinterpret_cast<uint8_t*>(const_cast<char*>(phone_number().c_str())));
      // allocate
      {
      std::string tmp_str(sizes[idx++], 'x');  // Preallocate needed size
      set_description(std::move(tmp_str));
      }
      //std::string tmp_str4(sizes[idx++], 'x');  // Preallocate needed size
      //set_description(std::move(tmp_str4));
      // store pointer in the pointers list
      ptrs.push_back(reinterpret_cast<uint8_t*>(const_cast<char*>(description().c_str())));
      idx = mutable_address()->generate_scatter_ptrs_and_allocate_from_sizes(ptrs, sizes, idx); 
      return idx;
  }
  size_t allocate_from_sizes(std::vector<size_t> &sizes, size_t idx = 0) {
      idx++;
      {
        std::string tmp_str(sizes[idx++], 'x');  // Preallocate needed size
        set_id(std::move(tmp_str));
      }
      {
        std::string tmp_str(sizes[idx++], 'x');  // Preallocate needed size
        set_name(std::move(tmp_str));
      }
      {
        std::string tmp_str(sizes[idx++], 'x');  // Preallocate needed size
        set_phone_number(std::move(tmp_str));
      }
      {
        std::string tmp_str(sizes[idx++], 'x');  // Preallocate needed size
        set_description(std::move(tmp_str));
      }
      idx = mutable_address()->allocate_from_sizes(sizes, idx); 
      return idx;
  }

  // accessors -------------------------------------------------------
  enum : int {
    kIdFieldNumber = 1,
    kNameFieldNumber = 2,
    kPhoneNumberFieldNumber = 3,
    kDescriptionFieldNumber = 4,
    kAddressFieldNumber = 5,
  };
  // string id = 1;
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* value);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // string name = 2;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // string phone_number = 3;
  void clear_phone_number() ;
  const std::string& phone_number() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_phone_number(Arg_&& arg, Args_... args);
  std::string* mutable_phone_number();
  PROTOBUF_NODISCARD std::string* release_phone_number();
  void set_allocated_phone_number(std::string* value);

  private:
  const std::string& _internal_phone_number() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_phone_number(
      const std::string& value);
  std::string* _internal_mutable_phone_number();

  public:
  // string description = 4;
  void clear_description() ;
  const std::string& description() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_description(Arg_&& arg, Args_... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* value);

  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(
      const std::string& value);
  std::string* _internal_mutable_description();

  public:
  // .hotelreservation.Address address = 5;
  bool has_address() const;
  void clear_address() ;
  const ::hotelreservation::Address& address() const;
  PROTOBUF_NODISCARD ::hotelreservation::Address* release_address();
  ::hotelreservation::Address* mutable_address();
  void set_allocated_address(::hotelreservation::Address* value);
  void unsafe_arena_set_allocated_address(::hotelreservation::Address* value);
  ::hotelreservation::Address* unsafe_arena_release_address();

  private:
  const ::hotelreservation::Address& _internal_address() const;
  ::hotelreservation::Address* _internal_mutable_address();

  public:
  // @@protoc_insertion_point(class_scope:hotelreservation.HotelProfile)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 1,
      67, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_HotelProfile_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr id_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::internal::ArenaStringPtr phone_number_;
    ::google::protobuf::internal::ArenaStringPtr description_;
    ::hotelreservation::Address* address_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_hotel_5freservation_2eproto;
};
// -------------------------------------------------------------------

class SearchResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:hotelreservation.SearchResponse) */ {
 public:
  inline SearchResponse() : SearchResponse(nullptr) {}
  ~SearchResponse() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SearchResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline SearchResponse(const SearchResponse& from) : SearchResponse(nullptr, from) {}
  inline SearchResponse(SearchResponse&& from) noexcept
      : SearchResponse(nullptr, std::move(from)) {}
  inline SearchResponse& operator=(const SearchResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SearchResponse& operator=(SearchResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SearchResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SearchResponse* internal_default_instance() {
    return reinterpret_cast<const SearchResponse*>(
        &_SearchResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 10;
  friend void swap(SearchResponse& a, SearchResponse& b) { a.Swap(&b); }
  inline void Swap(SearchResponse* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SearchResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SearchResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<SearchResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SearchResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SearchResponse& from) { SearchResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SearchResponse* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "hotelreservation.SearchResponse"; }

 protected:
  explicit SearchResponse(::google::protobuf::Arena* arena);
  SearchResponse(::google::protobuf::Arena* arena, const SearchResponse& from);
  SearchResponse(::google::protobuf::Arena* arena, SearchResponse&& from) noexcept
      : SearchResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // schemas for IAA/DSA ---------------------------------------------
  void generate_schema(std::vector<std::tuple<uint8_t*, size_t>> &schema) {
      for (int i = 0; i < hotels_size(); ++i) {
        mutable_hotels(i)->generate_schema(schema);
      }
  }
  void generate_seperated_schema(std::vector<uint8_t*> &ptrs_list, std::vector<size_t> &sizes_list) {
      ptrs_list.push_back(nullptr);
      sizes_list.push_back(0);
      ptrs_list.push_back(nullptr);
      sizes_list.push_back(hotels().size());
      for (int i = 0; i < hotels_size(); ++i) {
        mutable_hotels(i)->generate_seperated_schema(ptrs_list, sizes_list);
      }
  }
  void generate_scatter_ptrs(std::vector<uint8_t*> &ptrs) {
      ptrs.push_back(nullptr);
      ptrs.push_back(nullptr);
      for (int i = 0; i < hotels_size(); ++i) {
        mutable_hotels(i)->generate_scatter_ptrs(ptrs);
      }
  }
  void generate_scatter_sizes(std::vector<size_t> &sizes) {
      sizes.push_back(0);
      sizes.push_back(hotels().size());
      for (int i = 0; i < hotels_size(); ++i) {
        mutable_hotels(i)->generate_scatter_sizes(sizes);
      }
  }
  size_t generate_scatter_ptrs_and_allocate_from_sizes(std::vector<uint8_t*> &ptrs, std::vector<size_t> &sizes, size_t idx = 0) {
      idx++;
      // only primitive field pointers
      ptrs.push_back(nullptr);
      // non-primitive field pointers + allocation
      return idx;
  }
  size_t allocate_from_sizes(std::vector<size_t> &sizes, size_t idx = 0) {
      idx++;
      size_t num_hotels_entries = sizes[idx++];
      for (size_t i = 0; i < num_hotels_entries; ++i) {
        auto* new_msg = add_hotels();
        idx = new_msg->allocate_from_sizes(sizes, idx); 
        //idx = mutable_hotels(i)->allocate_from_sizes(sizes, idx); 
      }
      return idx;
  }

  // accessors -------------------------------------------------------
  enum : int {
    kHotelsFieldNumber = 1,
  };
  // repeated .hotelreservation.HotelProfile hotels = 1;
  int hotels_size() const;
  private:
  int _internal_hotels_size() const;

  public:
  void clear_hotels() ;
  ::hotelreservation::HotelProfile* mutable_hotels(int index);
  ::google::protobuf::RepeatedPtrField<::hotelreservation::HotelProfile>* mutable_hotels();

  private:
  const ::google::protobuf::RepeatedPtrField<::hotelreservation::HotelProfile>& _internal_hotels() const;
  ::google::protobuf::RepeatedPtrField<::hotelreservation::HotelProfile>* _internal_mutable_hotels();
  public:
  const ::hotelreservation::HotelProfile& hotels(int index) const;
  ::hotelreservation::HotelProfile* add_hotels();
  const ::google::protobuf::RepeatedPtrField<::hotelreservation::HotelProfile>& hotels() const;
  // @@protoc_insertion_point(class_scope:hotelreservation.SearchResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_SearchResponse_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField< ::hotelreservation::HotelProfile > hotels_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_hotel_5freservation_2eproto;
};
// -------------------------------------------------------------------

class RecommendResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:hotelreservation.RecommendResponse) */ {
 public:
  inline RecommendResponse() : RecommendResponse(nullptr) {}
  ~RecommendResponse() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RecommendResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline RecommendResponse(const RecommendResponse& from) : RecommendResponse(nullptr, from) {}
  inline RecommendResponse(RecommendResponse&& from) noexcept
      : RecommendResponse(nullptr, std::move(from)) {}
  inline RecommendResponse& operator=(const RecommendResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RecommendResponse& operator=(RecommendResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RecommendResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const RecommendResponse* internal_default_instance() {
    return reinterpret_cast<const RecommendResponse*>(
        &_RecommendResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 12;
  friend void swap(RecommendResponse& a, RecommendResponse& b) { a.Swap(&b); }
  inline void Swap(RecommendResponse* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RecommendResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RecommendResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<RecommendResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RecommendResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RecommendResponse& from) { RecommendResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RecommendResponse* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "hotelreservation.RecommendResponse"; }

 protected:
  explicit RecommendResponse(::google::protobuf::Arena* arena);
  RecommendResponse(::google::protobuf::Arena* arena, const RecommendResponse& from);
  RecommendResponse(::google::protobuf::Arena* arena, RecommendResponse&& from) noexcept
      : RecommendResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // schemas for IAA/DSA ---------------------------------------------
  void generate_schema(std::vector<std::tuple<uint8_t*, size_t>> &schema) {
      for (int i = 0; i < hotels_size(); ++i) {
        mutable_hotels(i)->generate_schema(schema);
      }
  }
  void generate_seperated_schema(std::vector<uint8_t*> &ptrs_list, std::vector<size_t> &sizes_list) {
      ptrs_list.push_back(nullptr);
      sizes_list.push_back(0);
      ptrs_list.push_back(nullptr);
      sizes_list.push_back(hotels().size());
      for (int i = 0; i < hotels_size(); ++i) {
        mutable_hotels(i)->generate_seperated_schema(ptrs_list, sizes_list);
      }
  }
  void generate_scatter_ptrs(std::vector<uint8_t*> &ptrs) {
      ptrs.push_back(nullptr);
      ptrs.push_back(nullptr);
      for (int i = 0; i < hotels_size(); ++i) {
        mutable_hotels(i)->generate_scatter_ptrs(ptrs);
      }
  }
  void generate_scatter_sizes(std::vector<size_t> &sizes) {
      sizes.push_back(0);
      sizes.push_back(hotels().size());
      for (int i = 0; i < hotels_size(); ++i) {
        mutable_hotels(i)->generate_scatter_sizes(sizes);
      }
  }
  size_t generate_scatter_ptrs_and_allocate_from_sizes(std::vector<uint8_t*> &ptrs, std::vector<size_t> &sizes, size_t idx = 0) {
      idx++;
      // only primitive field pointers
      ptrs.push_back(nullptr);
      // non-primitive field pointers + allocation
      return idx;
  }
  size_t allocate_from_sizes(std::vector<size_t> &sizes, size_t idx = 0) {
      idx++;
      size_t num_hotels_entries = sizes[idx++];
      for (size_t i = 0; i < num_hotels_entries; ++i) {
        auto* new_msg = add_hotels();
        idx = new_msg->allocate_from_sizes(sizes, idx); 
        //idx = mutable_hotels(i)->allocate_from_sizes(sizes, idx); 
      }
      return idx;
  }

  // accessors -------------------------------------------------------
  enum : int {
    kHotelsFieldNumber = 1,
  };
  // repeated .hotelreservation.HotelProfile hotels = 1;
  int hotels_size() const;
  private:
  int _internal_hotels_size() const;

  public:
  void clear_hotels() ;
  ::hotelreservation::HotelProfile* mutable_hotels(int index);
  ::google::protobuf::RepeatedPtrField<::hotelreservation::HotelProfile>* mutable_hotels();

  private:
  const ::google::protobuf::RepeatedPtrField<::hotelreservation::HotelProfile>& _internal_hotels() const;
  ::google::protobuf::RepeatedPtrField<::hotelreservation::HotelProfile>* _internal_mutable_hotels();
  public:
  const ::hotelreservation::HotelProfile& hotels(int index) const;
  ::hotelreservation::HotelProfile* add_hotels();
  const ::google::protobuf::RepeatedPtrField<::hotelreservation::HotelProfile>& hotels() const;
  // @@protoc_insertion_point(class_scope:hotelreservation.RecommendResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_RecommendResponse_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField< ::hotelreservation::HotelProfile > hotels_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_hotel_5freservation_2eproto;
};
// -------------------------------------------------------------------

class GetRatesResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:hotelreservation.GetRatesResponse) */ {
 public:
  inline GetRatesResponse() : GetRatesResponse(nullptr) {}
  ~GetRatesResponse() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GetRatesResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline GetRatesResponse(const GetRatesResponse& from) : GetRatesResponse(nullptr, from) {}
  inline GetRatesResponse(GetRatesResponse&& from) noexcept
      : GetRatesResponse(nullptr, std::move(from)) {}
  inline GetRatesResponse& operator=(const GetRatesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetRatesResponse& operator=(GetRatesResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetRatesResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetRatesResponse* internal_default_instance() {
    return reinterpret_cast<const GetRatesResponse*>(
        &_GetRatesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 22;
  friend void swap(GetRatesResponse& a, GetRatesResponse& b) { a.Swap(&b); }
  inline void Swap(GetRatesResponse* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetRatesResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetRatesResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<GetRatesResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetRatesResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GetRatesResponse& from) { GetRatesResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GetRatesResponse* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "hotelreservation.GetRatesResponse"; }

 protected:
  explicit GetRatesResponse(::google::protobuf::Arena* arena);
  GetRatesResponse(::google::protobuf::Arena* arena, const GetRatesResponse& from);
  GetRatesResponse(::google::protobuf::Arena* arena, GetRatesResponse&& from) noexcept
      : GetRatesResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // schemas for IAA/DSA ---------------------------------------------
  void generate_schema(std::vector<std::tuple<uint8_t*, size_t>> &schema) {
      for (int i = 0; i < rate_plans_size(); ++i) {
        mutable_rate_plans(i)->generate_schema(schema);
      }
  }
  void generate_seperated_schema(std::vector<uint8_t*> &ptrs_list, std::vector<size_t> &sizes_list) {
      ptrs_list.push_back(nullptr);
      sizes_list.push_back(0);
      ptrs_list.push_back(nullptr);
      sizes_list.push_back(rate_plans().size());
      for (int i = 0; i < rate_plans_size(); ++i) {
        mutable_rate_plans(i)->generate_seperated_schema(ptrs_list, sizes_list);
      }
  }
  void generate_scatter_ptrs(std::vector<uint8_t*> &ptrs) {
      ptrs.push_back(nullptr);
      ptrs.push_back(nullptr);
      for (int i = 0; i < rate_plans_size(); ++i) {
        mutable_rate_plans(i)->generate_scatter_ptrs(ptrs);
      }
  }
  void generate_scatter_sizes(std::vector<size_t> &sizes) {
      sizes.push_back(0);
      sizes.push_back(rate_plans().size());
      for (int i = 0; i < rate_plans_size(); ++i) {
        mutable_rate_plans(i)->generate_scatter_sizes(sizes);
      }
  }
  size_t generate_scatter_ptrs_and_allocate_from_sizes(std::vector<uint8_t*> &ptrs, std::vector<size_t> &sizes, size_t idx = 0) {
      idx++;
      // only primitive field pointers
      ptrs.push_back(nullptr);
      // non-primitive field pointers + allocation
      return idx;
  }
  size_t allocate_from_sizes(std::vector<size_t> &sizes, size_t idx = 0) {
      idx++;
      size_t num_rate_plans_entries = sizes[idx++];
      for (size_t i = 0; i < num_rate_plans_entries; ++i) {
        auto* new_msg = add_rate_plans();
        idx = new_msg->allocate_from_sizes(sizes, idx); 
        //idx = mutable_rate_plans(i)->allocate_from_sizes(sizes, idx); 
      }
      return idx;
  }

  // accessors -------------------------------------------------------
  enum : int {
    kRatePlansFieldNumber = 1,
  };
  // repeated .hotelreservation.RatePlan rate_plans = 1;
  int rate_plans_size() const;
  private:
  int _internal_rate_plans_size() const;

  public:
  void clear_rate_plans() ;
  ::hotelreservation::RatePlan* mutable_rate_plans(int index);
  ::google::protobuf::RepeatedPtrField<::hotelreservation::RatePlan>* mutable_rate_plans();

  private:
  const ::google::protobuf::RepeatedPtrField<::hotelreservation::RatePlan>& _internal_rate_plans() const;
  ::google::protobuf::RepeatedPtrField<::hotelreservation::RatePlan>* _internal_mutable_rate_plans();
  public:
  const ::hotelreservation::RatePlan& rate_plans(int index) const;
  ::hotelreservation::RatePlan* add_rate_plans();
  const ::google::protobuf::RepeatedPtrField<::hotelreservation::RatePlan>& rate_plans() const;
  // @@protoc_insertion_point(class_scope:hotelreservation.GetRatesResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_GetRatesResponse_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField< ::hotelreservation::RatePlan > rate_plans_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_hotel_5freservation_2eproto;
};
// -------------------------------------------------------------------

class GetProfilesResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:hotelreservation.GetProfilesResponse) */ {
 public:
  inline GetProfilesResponse() : GetProfilesResponse(nullptr) {}
  ~GetProfilesResponse() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GetProfilesResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline GetProfilesResponse(const GetProfilesResponse& from) : GetProfilesResponse(nullptr, from) {}
  inline GetProfilesResponse(GetProfilesResponse&& from) noexcept
      : GetProfilesResponse(nullptr, std::move(from)) {}
  inline GetProfilesResponse& operator=(const GetProfilesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetProfilesResponse& operator=(GetProfilesResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetProfilesResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetProfilesResponse* internal_default_instance() {
    return reinterpret_cast<const GetProfilesResponse*>(
        &_GetProfilesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 20;
  friend void swap(GetProfilesResponse& a, GetProfilesResponse& b) { a.Swap(&b); }
  inline void Swap(GetProfilesResponse* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetProfilesResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetProfilesResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<GetProfilesResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetProfilesResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GetProfilesResponse& from) { GetProfilesResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GetProfilesResponse* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "hotelreservation.GetProfilesResponse"; }

 protected:
  explicit GetProfilesResponse(::google::protobuf::Arena* arena);
  GetProfilesResponse(::google::protobuf::Arena* arena, const GetProfilesResponse& from);
  GetProfilesResponse(::google::protobuf::Arena* arena, GetProfilesResponse&& from) noexcept
      : GetProfilesResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // schemas for IAA/DSA ---------------------------------------------
  void generate_schema(std::vector<std::tuple<uint8_t*, size_t>> &schema) {
      for (int i = 0; i < profiles_size(); ++i) {
        mutable_profiles(i)->generate_schema(schema);
      }
  }
  void generate_seperated_schema(std::vector<uint8_t*> &ptrs_list, std::vector<size_t> &sizes_list) {
      ptrs_list.push_back(nullptr);
      sizes_list.push_back(0);
      ptrs_list.push_back(nullptr);
      sizes_list.push_back(profiles().size());
      for (int i = 0; i < profiles_size(); ++i) {
        mutable_profiles(i)->generate_seperated_schema(ptrs_list, sizes_list);
      }
  }
  void generate_scatter_ptrs(std::vector<uint8_t*> &ptrs) {
      ptrs.push_back(nullptr);
      ptrs.push_back(nullptr);
      for (int i = 0; i < profiles_size(); ++i) {
        mutable_profiles(i)->generate_scatter_ptrs(ptrs);
      }
  }
  void generate_scatter_sizes(std::vector<size_t> &sizes) {
      sizes.push_back(0);
      sizes.push_back(profiles().size());
      for (int i = 0; i < profiles_size(); ++i) {
        mutable_profiles(i)->generate_scatter_sizes(sizes);
      }
  }
  size_t generate_scatter_ptrs_and_allocate_from_sizes(std::vector<uint8_t*> &ptrs, std::vector<size_t> &sizes, size_t idx = 0) {
      idx++;
      // only primitive field pointers
      ptrs.push_back(nullptr);
      // non-primitive field pointers + allocation
      return idx;
  }
  size_t allocate_from_sizes(std::vector<size_t> &sizes, size_t idx = 0) {
      idx++;
      size_t num_profiles_entries = sizes[idx++];
      for (size_t i = 0; i < num_profiles_entries; ++i) {
        auto* new_msg = add_profiles();
        idx = new_msg->allocate_from_sizes(sizes, idx); 
        //idx = mutable_profiles(i)->allocate_from_sizes(sizes, idx); 
      }
      return idx;
  }

  // accessors -------------------------------------------------------
  enum : int {
    kProfilesFieldNumber = 1,
  };
  // repeated .hotelreservation.HotelProfile profiles = 1;
  int profiles_size() const;
  private:
  int _internal_profiles_size() const;

  public:
  void clear_profiles() ;
  ::hotelreservation::HotelProfile* mutable_profiles(int index);
  ::google::protobuf::RepeatedPtrField<::hotelreservation::HotelProfile>* mutable_profiles();

  private:
  const ::google::protobuf::RepeatedPtrField<::hotelreservation::HotelProfile>& _internal_profiles() const;
  ::google::protobuf::RepeatedPtrField<::hotelreservation::HotelProfile>* _internal_mutable_profiles();
  public:
  const ::hotelreservation::HotelProfile& profiles(int index) const;
  ::hotelreservation::HotelProfile* add_profiles();
  const ::google::protobuf::RepeatedPtrField<::hotelreservation::HotelProfile>& profiles() const;
  // @@protoc_insertion_point(class_scope:hotelreservation.GetProfilesResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_GetProfilesResponse_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField< ::hotelreservation::HotelProfile > profiles_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_hotel_5freservation_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// Point

// string pid = 1;
inline void Point::clear_pid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.pid_.ClearToEmpty();
}
inline const std::string& Point::pid() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:hotelreservation.Point.pid)
  return _internal_pid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Point::set_pid(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.pid_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:hotelreservation.Point.pid)
}
inline std::string* Point::mutable_pid() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_pid();
  // @@protoc_insertion_point(field_mutable:hotelreservation.Point.pid)
  return _s;
}
inline const std::string& Point::_internal_pid() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.pid_.Get();
}
inline void Point::_internal_set_pid(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.pid_.Set(value, GetArena());
}
inline std::string* Point::_internal_mutable_pid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.pid_.Mutable( GetArena());
}
inline std::string* Point::release_pid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:hotelreservation.Point.pid)
  return _impl_.pid_.Release();
}
inline void Point::set_allocated_pid(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.pid_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.pid_.IsDefault()) {
          _impl_.pid_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hotelreservation.Point.pid)
}

// double plat = 2;
inline void Point::clear_plat() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.plat_ = 0;
}
inline double Point::plat() const {
  // @@protoc_insertion_point(field_get:hotelreservation.Point.plat)
  return _internal_plat();
}
inline void Point::set_plat(double value) {
  _internal_set_plat(value);
  // @@protoc_insertion_point(field_set:hotelreservation.Point.plat)
}
inline double Point::_internal_plat() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.plat_;
}
inline void Point::_internal_set_plat(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.plat_ = value;
}

// double plon = 3;
inline void Point::clear_plon() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.plon_ = 0;
}
inline double Point::plon() const {
  // @@protoc_insertion_point(field_get:hotelreservation.Point.plon)
  return _internal_plon();
}
inline void Point::set_plon(double value) {
  _internal_set_plon(value);
  // @@protoc_insertion_point(field_set:hotelreservation.Point.plon)
}
inline double Point::_internal_plon() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.plon_;
}
inline void Point::_internal_set_plon(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.plon_ = value;
}

// -------------------------------------------------------------------

// User

// string username = 1;
inline void User::clear_username() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.username_.ClearToEmpty();
}
inline const std::string& User::username() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:hotelreservation.User.username)
  return _internal_username();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void User::set_username(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.username_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:hotelreservation.User.username)
}
inline std::string* User::mutable_username() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:hotelreservation.User.username)
  return _s;
}
inline const std::string& User::_internal_username() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.username_.Get();
}
inline void User::_internal_set_username(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.username_.Set(value, GetArena());
}
inline std::string* User::_internal_mutable_username() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.username_.Mutable( GetArena());
}
inline std::string* User::release_username() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:hotelreservation.User.username)
  return _impl_.username_.Release();
}
inline void User::set_allocated_username(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.username_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.username_.IsDefault()) {
          _impl_.username_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hotelreservation.User.username)
}

// string password = 2;
inline void User::clear_password() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.password_.ClearToEmpty();
}
inline const std::string& User::password() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:hotelreservation.User.password)
  return _internal_password();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void User::set_password(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.password_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:hotelreservation.User.password)
}
inline std::string* User::mutable_password() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:hotelreservation.User.password)
  return _s;
}
inline const std::string& User::_internal_password() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.password_.Get();
}
inline void User::_internal_set_password(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.password_.Set(value, GetArena());
}
inline std::string* User::_internal_mutable_password() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.password_.Mutable( GetArena());
}
inline std::string* User::release_password() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:hotelreservation.User.password)
  return _impl_.password_.Release();
}
inline void User::set_allocated_password(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.password_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.password_.IsDefault()) {
          _impl_.password_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hotelreservation.User.password)
}

// -------------------------------------------------------------------

// RoomType

// double bookable_rate = 1;
inline void RoomType::clear_bookable_rate() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.bookable_rate_ = 0;
}
inline double RoomType::bookable_rate() const {
  // @@protoc_insertion_point(field_get:hotelreservation.RoomType.bookable_rate)
  return _internal_bookable_rate();
}
inline void RoomType::set_bookable_rate(double value) {
  _internal_set_bookable_rate(value);
  // @@protoc_insertion_point(field_set:hotelreservation.RoomType.bookable_rate)
}
inline double RoomType::_internal_bookable_rate() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.bookable_rate_;
}
inline void RoomType::_internal_set_bookable_rate(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.bookable_rate_ = value;
}

// string code = 2;
inline void RoomType::clear_code() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.code_.ClearToEmpty();
}
inline const std::string& RoomType::code() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:hotelreservation.RoomType.code)
  return _internal_code();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RoomType::set_code(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.code_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:hotelreservation.RoomType.code)
}
inline std::string* RoomType::mutable_code() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_code();
  // @@protoc_insertion_point(field_mutable:hotelreservation.RoomType.code)
  return _s;
}
inline const std::string& RoomType::_internal_code() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.code_.Get();
}
inline void RoomType::_internal_set_code(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.code_.Set(value, GetArena());
}
inline std::string* RoomType::_internal_mutable_code() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.code_.Mutable( GetArena());
}
inline std::string* RoomType::release_code() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:hotelreservation.RoomType.code)
  return _impl_.code_.Release();
}
inline void RoomType::set_allocated_code(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.code_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.code_.IsDefault()) {
          _impl_.code_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hotelreservation.RoomType.code)
}

// string room_description = 3;
inline void RoomType::clear_room_description() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.room_description_.ClearToEmpty();
}
inline const std::string& RoomType::room_description() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:hotelreservation.RoomType.room_description)
  return _internal_room_description();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RoomType::set_room_description(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.room_description_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:hotelreservation.RoomType.room_description)
}
inline std::string* RoomType::mutable_room_description() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_room_description();
  // @@protoc_insertion_point(field_mutable:hotelreservation.RoomType.room_description)
  return _s;
}
inline const std::string& RoomType::_internal_room_description() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.room_description_.Get();
}
inline void RoomType::_internal_set_room_description(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.room_description_.Set(value, GetArena());
}
inline std::string* RoomType::_internal_mutable_room_description() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.room_description_.Mutable( GetArena());
}
inline std::string* RoomType::release_room_description() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:hotelreservation.RoomType.room_description)
  return _impl_.room_description_.Release();
}
inline void RoomType::set_allocated_room_description(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.room_description_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.room_description_.IsDefault()) {
          _impl_.room_description_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hotelreservation.RoomType.room_description)
}

// double total_rate = 4;
inline void RoomType::clear_total_rate() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.total_rate_ = 0;
}
inline double RoomType::total_rate() const {
  // @@protoc_insertion_point(field_get:hotelreservation.RoomType.total_rate)
  return _internal_total_rate();
}
inline void RoomType::set_total_rate(double value) {
  _internal_set_total_rate(value);
  // @@protoc_insertion_point(field_set:hotelreservation.RoomType.total_rate)
}
inline double RoomType::_internal_total_rate() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.total_rate_;
}
inline void RoomType::_internal_set_total_rate(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.total_rate_ = value;
}

// double total_rate_inclusive = 5;
inline void RoomType::clear_total_rate_inclusive() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.total_rate_inclusive_ = 0;
}
inline double RoomType::total_rate_inclusive() const {
  // @@protoc_insertion_point(field_get:hotelreservation.RoomType.total_rate_inclusive)
  return _internal_total_rate_inclusive();
}
inline void RoomType::set_total_rate_inclusive(double value) {
  _internal_set_total_rate_inclusive(value);
  // @@protoc_insertion_point(field_set:hotelreservation.RoomType.total_rate_inclusive)
}
inline double RoomType::_internal_total_rate_inclusive() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.total_rate_inclusive_;
}
inline void RoomType::_internal_set_total_rate_inclusive(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.total_rate_inclusive_ = value;
}

// -------------------------------------------------------------------

// RatePlan

// string hotel_id = 1;
inline void RatePlan::clear_hotel_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.hotel_id_.ClearToEmpty();
}
inline const std::string& RatePlan::hotel_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:hotelreservation.RatePlan.hotel_id)
  return _internal_hotel_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RatePlan::set_hotel_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.hotel_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:hotelreservation.RatePlan.hotel_id)
}
inline std::string* RatePlan::mutable_hotel_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_hotel_id();
  // @@protoc_insertion_point(field_mutable:hotelreservation.RatePlan.hotel_id)
  return _s;
}
inline const std::string& RatePlan::_internal_hotel_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.hotel_id_.Get();
}
inline void RatePlan::_internal_set_hotel_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.hotel_id_.Set(value, GetArena());
}
inline std::string* RatePlan::_internal_mutable_hotel_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.hotel_id_.Mutable( GetArena());
}
inline std::string* RatePlan::release_hotel_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:hotelreservation.RatePlan.hotel_id)
  return _impl_.hotel_id_.Release();
}
inline void RatePlan::set_allocated_hotel_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.hotel_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.hotel_id_.IsDefault()) {
          _impl_.hotel_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hotelreservation.RatePlan.hotel_id)
}

// string code = 2;
inline void RatePlan::clear_code() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.code_.ClearToEmpty();
}
inline const std::string& RatePlan::code() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:hotelreservation.RatePlan.code)
  return _internal_code();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RatePlan::set_code(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.code_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:hotelreservation.RatePlan.code)
}
inline std::string* RatePlan::mutable_code() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_code();
  // @@protoc_insertion_point(field_mutable:hotelreservation.RatePlan.code)
  return _s;
}
inline const std::string& RatePlan::_internal_code() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.code_.Get();
}
inline void RatePlan::_internal_set_code(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.code_.Set(value, GetArena());
}
inline std::string* RatePlan::_internal_mutable_code() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.code_.Mutable( GetArena());
}
inline std::string* RatePlan::release_code() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:hotelreservation.RatePlan.code)
  return _impl_.code_.Release();
}
inline void RatePlan::set_allocated_code(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.code_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.code_.IsDefault()) {
          _impl_.code_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hotelreservation.RatePlan.code)
}

// string in_date = 3;
inline void RatePlan::clear_in_date() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.in_date_.ClearToEmpty();
}
inline const std::string& RatePlan::in_date() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:hotelreservation.RatePlan.in_date)
  return _internal_in_date();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RatePlan::set_in_date(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.in_date_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:hotelreservation.RatePlan.in_date)
}
inline std::string* RatePlan::mutable_in_date() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_in_date();
  // @@protoc_insertion_point(field_mutable:hotelreservation.RatePlan.in_date)
  return _s;
}
inline const std::string& RatePlan::_internal_in_date() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.in_date_.Get();
}
inline void RatePlan::_internal_set_in_date(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.in_date_.Set(value, GetArena());
}
inline std::string* RatePlan::_internal_mutable_in_date() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.in_date_.Mutable( GetArena());
}
inline std::string* RatePlan::release_in_date() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:hotelreservation.RatePlan.in_date)
  return _impl_.in_date_.Release();
}
inline void RatePlan::set_allocated_in_date(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.in_date_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.in_date_.IsDefault()) {
          _impl_.in_date_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hotelreservation.RatePlan.in_date)
}

// string out_date = 4;
inline void RatePlan::clear_out_date() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.out_date_.ClearToEmpty();
}
inline const std::string& RatePlan::out_date() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:hotelreservation.RatePlan.out_date)
  return _internal_out_date();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RatePlan::set_out_date(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.out_date_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:hotelreservation.RatePlan.out_date)
}
inline std::string* RatePlan::mutable_out_date() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_out_date();
  // @@protoc_insertion_point(field_mutable:hotelreservation.RatePlan.out_date)
  return _s;
}
inline const std::string& RatePlan::_internal_out_date() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.out_date_.Get();
}
inline void RatePlan::_internal_set_out_date(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.out_date_.Set(value, GetArena());
}
inline std::string* RatePlan::_internal_mutable_out_date() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.out_date_.Mutable( GetArena());
}
inline std::string* RatePlan::release_out_date() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:hotelreservation.RatePlan.out_date)
  return _impl_.out_date_.Release();
}
inline void RatePlan::set_allocated_out_date(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.out_date_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.out_date_.IsDefault()) {
          _impl_.out_date_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hotelreservation.RatePlan.out_date)
}

// .hotelreservation.RoomType room_type = 5;
inline bool RatePlan::has_room_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.room_type_ != nullptr);
  return value;
}
inline void RatePlan::clear_room_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.room_type_ != nullptr) _impl_.room_type_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::hotelreservation::RoomType& RatePlan::_internal_room_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::hotelreservation::RoomType* p = _impl_.room_type_;
  return p != nullptr ? *p : reinterpret_cast<const ::hotelreservation::RoomType&>(::hotelreservation::_RoomType_default_instance_);
}
inline const ::hotelreservation::RoomType& RatePlan::room_type() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:hotelreservation.RatePlan.room_type)
  return _internal_room_type();
}
inline void RatePlan::unsafe_arena_set_allocated_room_type(::hotelreservation::RoomType* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.room_type_);
  }
  _impl_.room_type_ = reinterpret_cast<::hotelreservation::RoomType*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hotelreservation.RatePlan.room_type)
}
inline ::hotelreservation::RoomType* RatePlan::release_room_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::hotelreservation::RoomType* released = _impl_.room_type_;
  _impl_.room_type_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::hotelreservation::RoomType* RatePlan::unsafe_arena_release_room_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:hotelreservation.RatePlan.room_type)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::hotelreservation::RoomType* temp = _impl_.room_type_;
  _impl_.room_type_ = nullptr;
  return temp;
}
inline ::hotelreservation::RoomType* RatePlan::_internal_mutable_room_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.room_type_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::hotelreservation::RoomType>(GetArena());
    _impl_.room_type_ = reinterpret_cast<::hotelreservation::RoomType*>(p);
  }
  return _impl_.room_type_;
}
inline ::hotelreservation::RoomType* RatePlan::mutable_room_type() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::hotelreservation::RoomType* _msg = _internal_mutable_room_type();
  // @@protoc_insertion_point(field_mutable:hotelreservation.RatePlan.room_type)
  return _msg;
}
inline void RatePlan::set_allocated_room_type(::hotelreservation::RoomType* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.room_type_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.room_type_ = reinterpret_cast<::hotelreservation::RoomType*>(value);
  // @@protoc_insertion_point(field_set_allocated:hotelreservation.RatePlan.room_type)
}

// -------------------------------------------------------------------

// Reservation

// string hotel_id = 1;
inline void Reservation::clear_hotel_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.hotel_id_.ClearToEmpty();
}
inline const std::string& Reservation::hotel_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:hotelreservation.Reservation.hotel_id)
  return _internal_hotel_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Reservation::set_hotel_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.hotel_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:hotelreservation.Reservation.hotel_id)
}
inline std::string* Reservation::mutable_hotel_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_hotel_id();
  // @@protoc_insertion_point(field_mutable:hotelreservation.Reservation.hotel_id)
  return _s;
}
inline const std::string& Reservation::_internal_hotel_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.hotel_id_.Get();
}
inline void Reservation::_internal_set_hotel_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.hotel_id_.Set(value, GetArena());
}
inline std::string* Reservation::_internal_mutable_hotel_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.hotel_id_.Mutable( GetArena());
}
inline std::string* Reservation::release_hotel_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:hotelreservation.Reservation.hotel_id)
  return _impl_.hotel_id_.Release();
}
inline void Reservation::set_allocated_hotel_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.hotel_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.hotel_id_.IsDefault()) {
          _impl_.hotel_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hotelreservation.Reservation.hotel_id)
}

// string customer_name = 2;
inline void Reservation::clear_customer_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.customer_name_.ClearToEmpty();
}
inline const std::string& Reservation::customer_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:hotelreservation.Reservation.customer_name)
  return _internal_customer_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Reservation::set_customer_name(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.customer_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:hotelreservation.Reservation.customer_name)
}
inline std::string* Reservation::mutable_customer_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_customer_name();
  // @@protoc_insertion_point(field_mutable:hotelreservation.Reservation.customer_name)
  return _s;
}
inline const std::string& Reservation::_internal_customer_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.customer_name_.Get();
}
inline void Reservation::_internal_set_customer_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.customer_name_.Set(value, GetArena());
}
inline std::string* Reservation::_internal_mutable_customer_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.customer_name_.Mutable( GetArena());
}
inline std::string* Reservation::release_customer_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:hotelreservation.Reservation.customer_name)
  return _impl_.customer_name_.Release();
}
inline void Reservation::set_allocated_customer_name(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.customer_name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.customer_name_.IsDefault()) {
          _impl_.customer_name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hotelreservation.Reservation.customer_name)
}

// string in_date = 3;
inline void Reservation::clear_in_date() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.in_date_.ClearToEmpty();
}
inline const std::string& Reservation::in_date() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:hotelreservation.Reservation.in_date)
  return _internal_in_date();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Reservation::set_in_date(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.in_date_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:hotelreservation.Reservation.in_date)
}
inline std::string* Reservation::mutable_in_date() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_in_date();
  // @@protoc_insertion_point(field_mutable:hotelreservation.Reservation.in_date)
  return _s;
}
inline const std::string& Reservation::_internal_in_date() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.in_date_.Get();
}
inline void Reservation::_internal_set_in_date(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.in_date_.Set(value, GetArena());
}
inline std::string* Reservation::_internal_mutable_in_date() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.in_date_.Mutable( GetArena());
}
inline std::string* Reservation::release_in_date() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:hotelreservation.Reservation.in_date)
  return _impl_.in_date_.Release();
}
inline void Reservation::set_allocated_in_date(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.in_date_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.in_date_.IsDefault()) {
          _impl_.in_date_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hotelreservation.Reservation.in_date)
}

// string out_date = 4;
inline void Reservation::clear_out_date() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.out_date_.ClearToEmpty();
}
inline const std::string& Reservation::out_date() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:hotelreservation.Reservation.out_date)
  return _internal_out_date();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Reservation::set_out_date(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.out_date_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:hotelreservation.Reservation.out_date)
}
inline std::string* Reservation::mutable_out_date() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_out_date();
  // @@protoc_insertion_point(field_mutable:hotelreservation.Reservation.out_date)
  return _s;
}
inline const std::string& Reservation::_internal_out_date() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.out_date_.Get();
}
inline void Reservation::_internal_set_out_date(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.out_date_.Set(value, GetArena());
}
inline std::string* Reservation::_internal_mutable_out_date() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.out_date_.Mutable( GetArena());
}
inline std::string* Reservation::release_out_date() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:hotelreservation.Reservation.out_date)
  return _impl_.out_date_.Release();
}
inline void Reservation::set_allocated_out_date(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.out_date_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.out_date_.IsDefault()) {
          _impl_.out_date_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hotelreservation.Reservation.out_date)
}

// int64 number = 5;
inline void Reservation::clear_number() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.number_ = ::int64_t{0};
}
inline ::int64_t Reservation::number() const {
  // @@protoc_insertion_point(field_get:hotelreservation.Reservation.number)
  return _internal_number();
}
inline void Reservation::set_number(::int64_t value) {
  _internal_set_number(value);
  // @@protoc_insertion_point(field_set:hotelreservation.Reservation.number)
}
inline ::int64_t Reservation::_internal_number() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.number_;
}
inline void Reservation::_internal_set_number(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.number_ = value;
}

// -------------------------------------------------------------------

// HotelNumber

// string hotel_id = 1;
inline void HotelNumber::clear_hotel_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.hotel_id_.ClearToEmpty();
}
inline const std::string& HotelNumber::hotel_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:hotelreservation.HotelNumber.hotel_id)
  return _internal_hotel_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void HotelNumber::set_hotel_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.hotel_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:hotelreservation.HotelNumber.hotel_id)
}
inline std::string* HotelNumber::mutable_hotel_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_hotel_id();
  // @@protoc_insertion_point(field_mutable:hotelreservation.HotelNumber.hotel_id)
  return _s;
}
inline const std::string& HotelNumber::_internal_hotel_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.hotel_id_.Get();
}
inline void HotelNumber::_internal_set_hotel_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.hotel_id_.Set(value, GetArena());
}
inline std::string* HotelNumber::_internal_mutable_hotel_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.hotel_id_.Mutable( GetArena());
}
inline std::string* HotelNumber::release_hotel_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:hotelreservation.HotelNumber.hotel_id)
  return _impl_.hotel_id_.Release();
}
inline void HotelNumber::set_allocated_hotel_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.hotel_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.hotel_id_.IsDefault()) {
          _impl_.hotel_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hotelreservation.HotelNumber.hotel_id)
}

// int64 number = 2;
inline void HotelNumber::clear_number() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.number_ = ::int64_t{0};
}
inline ::int64_t HotelNumber::number() const {
  // @@protoc_insertion_point(field_get:hotelreservation.HotelNumber.number)
  return _internal_number();
}
inline void HotelNumber::set_number(::int64_t value) {
  _internal_set_number(value);
  // @@protoc_insertion_point(field_set:hotelreservation.HotelNumber.number)
}
inline ::int64_t HotelNumber::_internal_number() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.number_;
}
inline void HotelNumber::_internal_set_number(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.number_ = value;
}

// -------------------------------------------------------------------

// Hotel

// string h_id = 1;
inline void Hotel::clear_h_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.h_id_.ClearToEmpty();
}
inline const std::string& Hotel::h_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:hotelreservation.Hotel.h_id)
  return _internal_h_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Hotel::set_h_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.h_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:hotelreservation.Hotel.h_id)
}
inline std::string* Hotel::mutable_h_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_h_id();
  // @@protoc_insertion_point(field_mutable:hotelreservation.Hotel.h_id)
  return _s;
}
inline const std::string& Hotel::_internal_h_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.h_id_.Get();
}
inline void Hotel::_internal_set_h_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.h_id_.Set(value, GetArena());
}
inline std::string* Hotel::_internal_mutable_h_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.h_id_.Mutable( GetArena());
}
inline std::string* Hotel::release_h_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:hotelreservation.Hotel.h_id)
  return _impl_.h_id_.Release();
}
inline void Hotel::set_allocated_h_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.h_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.h_id_.IsDefault()) {
          _impl_.h_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hotelreservation.Hotel.h_id)
}

// double h_lat = 2;
inline void Hotel::clear_h_lat() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.h_lat_ = 0;
}
inline double Hotel::h_lat() const {
  // @@protoc_insertion_point(field_get:hotelreservation.Hotel.h_lat)
  return _internal_h_lat();
}
inline void Hotel::set_h_lat(double value) {
  _internal_set_h_lat(value);
  // @@protoc_insertion_point(field_set:hotelreservation.Hotel.h_lat)
}
inline double Hotel::_internal_h_lat() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.h_lat_;
}
inline void Hotel::_internal_set_h_lat(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.h_lat_ = value;
}

// double h_lon = 3;
inline void Hotel::clear_h_lon() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.h_lon_ = 0;
}
inline double Hotel::h_lon() const {
  // @@protoc_insertion_point(field_get:hotelreservation.Hotel.h_lon)
  return _internal_h_lon();
}
inline void Hotel::set_h_lon(double value) {
  _internal_set_h_lon(value);
  // @@protoc_insertion_point(field_set:hotelreservation.Hotel.h_lon)
}
inline double Hotel::_internal_h_lon() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.h_lon_;
}
inline void Hotel::_internal_set_h_lon(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.h_lon_ = value;
}

// double h_rate = 4;
inline void Hotel::clear_h_rate() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.h_rate_ = 0;
}
inline double Hotel::h_rate() const {
  // @@protoc_insertion_point(field_get:hotelreservation.Hotel.h_rate)
  return _internal_h_rate();
}
inline void Hotel::set_h_rate(double value) {
  _internal_set_h_rate(value);
  // @@protoc_insertion_point(field_set:hotelreservation.Hotel.h_rate)
}
inline double Hotel::_internal_h_rate() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.h_rate_;
}
inline void Hotel::_internal_set_h_rate(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.h_rate_ = value;
}

// double h_price = 5;
inline void Hotel::clear_h_price() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.h_price_ = 0;
}
inline double Hotel::h_price() const {
  // @@protoc_insertion_point(field_get:hotelreservation.Hotel.h_price)
  return _internal_h_price();
}
inline void Hotel::set_h_price(double value) {
  _internal_set_h_price(value);
  // @@protoc_insertion_point(field_set:hotelreservation.Hotel.h_price)
}
inline double Hotel::_internal_h_price() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.h_price_;
}
inline void Hotel::_internal_set_h_price(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.h_price_ = value;
}

// -------------------------------------------------------------------

// Address

// string street_number = 1;
inline void Address::clear_street_number() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.street_number_.ClearToEmpty();
}
inline const std::string& Address::street_number() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:hotelreservation.Address.street_number)
  return _internal_street_number();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Address::set_street_number(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.street_number_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:hotelreservation.Address.street_number)
}
inline std::string* Address::mutable_street_number() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_street_number();
  // @@protoc_insertion_point(field_mutable:hotelreservation.Address.street_number)
  return _s;
}
inline const std::string& Address::_internal_street_number() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.street_number_.Get();
}
inline void Address::_internal_set_street_number(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.street_number_.Set(value, GetArena());
}
inline std::string* Address::_internal_mutable_street_number() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.street_number_.Mutable( GetArena());
}
inline std::string* Address::release_street_number() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:hotelreservation.Address.street_number)
  return _impl_.street_number_.Release();
}
inline void Address::set_allocated_street_number(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.street_number_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.street_number_.IsDefault()) {
          _impl_.street_number_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hotelreservation.Address.street_number)
}

// string street_name = 2;
inline void Address::clear_street_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.street_name_.ClearToEmpty();
}
inline const std::string& Address::street_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:hotelreservation.Address.street_name)
  return _internal_street_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Address::set_street_name(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.street_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:hotelreservation.Address.street_name)
}
inline std::string* Address::mutable_street_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_street_name();
  // @@protoc_insertion_point(field_mutable:hotelreservation.Address.street_name)
  return _s;
}
inline const std::string& Address::_internal_street_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.street_name_.Get();
}
inline void Address::_internal_set_street_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.street_name_.Set(value, GetArena());
}
inline std::string* Address::_internal_mutable_street_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.street_name_.Mutable( GetArena());
}
inline std::string* Address::release_street_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:hotelreservation.Address.street_name)
  return _impl_.street_name_.Release();
}
inline void Address::set_allocated_street_name(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.street_name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.street_name_.IsDefault()) {
          _impl_.street_name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hotelreservation.Address.street_name)
}

// string city = 3;
inline void Address::clear_city() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.city_.ClearToEmpty();
}
inline const std::string& Address::city() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:hotelreservation.Address.city)
  return _internal_city();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Address::set_city(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.city_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:hotelreservation.Address.city)
}
inline std::string* Address::mutable_city() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_city();
  // @@protoc_insertion_point(field_mutable:hotelreservation.Address.city)
  return _s;
}
inline const std::string& Address::_internal_city() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.city_.Get();
}
inline void Address::_internal_set_city(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.city_.Set(value, GetArena());
}
inline std::string* Address::_internal_mutable_city() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.city_.Mutable( GetArena());
}
inline std::string* Address::release_city() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:hotelreservation.Address.city)
  return _impl_.city_.Release();
}
inline void Address::set_allocated_city(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.city_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.city_.IsDefault()) {
          _impl_.city_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hotelreservation.Address.city)
}

// string state = 4;
inline void Address::clear_state() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.state_.ClearToEmpty();
}
inline const std::string& Address::state() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:hotelreservation.Address.state)
  return _internal_state();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Address::set_state(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.state_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:hotelreservation.Address.state)
}
inline std::string* Address::mutable_state() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_state();
  // @@protoc_insertion_point(field_mutable:hotelreservation.Address.state)
  return _s;
}
inline const std::string& Address::_internal_state() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.state_.Get();
}
inline void Address::_internal_set_state(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.state_.Set(value, GetArena());
}
inline std::string* Address::_internal_mutable_state() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.state_.Mutable( GetArena());
}
inline std::string* Address::release_state() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:hotelreservation.Address.state)
  return _impl_.state_.Release();
}
inline void Address::set_allocated_state(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.state_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.state_.IsDefault()) {
          _impl_.state_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hotelreservation.Address.state)
}

// string country = 5;
inline void Address::clear_country() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.country_.ClearToEmpty();
}
inline const std::string& Address::country() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:hotelreservation.Address.country)
  return _internal_country();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Address::set_country(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.country_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:hotelreservation.Address.country)
}
inline std::string* Address::mutable_country() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_country();
  // @@protoc_insertion_point(field_mutable:hotelreservation.Address.country)
  return _s;
}
inline const std::string& Address::_internal_country() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.country_.Get();
}
inline void Address::_internal_set_country(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.country_.Set(value, GetArena());
}
inline std::string* Address::_internal_mutable_country() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.country_.Mutable( GetArena());
}
inline std::string* Address::release_country() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:hotelreservation.Address.country)
  return _impl_.country_.Release();
}
inline void Address::set_allocated_country(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.country_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.country_.IsDefault()) {
          _impl_.country_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hotelreservation.Address.country)
}

// string postal_code = 6;
inline void Address::clear_postal_code() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.postal_code_.ClearToEmpty();
}
inline const std::string& Address::postal_code() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:hotelreservation.Address.postal_code)
  return _internal_postal_code();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Address::set_postal_code(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.postal_code_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:hotelreservation.Address.postal_code)
}
inline std::string* Address::mutable_postal_code() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_postal_code();
  // @@protoc_insertion_point(field_mutable:hotelreservation.Address.postal_code)
  return _s;
}
inline const std::string& Address::_internal_postal_code() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.postal_code_.Get();
}
inline void Address::_internal_set_postal_code(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.postal_code_.Set(value, GetArena());
}
inline std::string* Address::_internal_mutable_postal_code() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.postal_code_.Mutable( GetArena());
}
inline std::string* Address::release_postal_code() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:hotelreservation.Address.postal_code)
  return _impl_.postal_code_.Release();
}
inline void Address::set_allocated_postal_code(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.postal_code_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.postal_code_.IsDefault()) {
          _impl_.postal_code_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hotelreservation.Address.postal_code)
}

// double lat = 7;
inline void Address::clear_lat() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.lat_ = 0;
}
inline double Address::lat() const {
  // @@protoc_insertion_point(field_get:hotelreservation.Address.lat)
  return _internal_lat();
}
inline void Address::set_lat(double value) {
  _internal_set_lat(value);
  // @@protoc_insertion_point(field_set:hotelreservation.Address.lat)
}
inline double Address::_internal_lat() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.lat_;
}
inline void Address::_internal_set_lat(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.lat_ = value;
}

// double lon = 8;
inline void Address::clear_lon() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.lon_ = 0;
}
inline double Address::lon() const {
  // @@protoc_insertion_point(field_get:hotelreservation.Address.lon)
  return _internal_lon();
}
inline void Address::set_lon(double value) {
  _internal_set_lon(value);
  // @@protoc_insertion_point(field_set:hotelreservation.Address.lon)
}
inline double Address::_internal_lon() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.lon_;
}
inline void Address::_internal_set_lon(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.lon_ = value;
}

// -------------------------------------------------------------------

// HotelProfile

// string id = 1;
inline void HotelProfile::clear_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.ClearToEmpty();
}
inline const std::string& HotelProfile::id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:hotelreservation.HotelProfile.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void HotelProfile::set_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:hotelreservation.HotelProfile.id)
}
inline std::string* HotelProfile::mutable_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:hotelreservation.HotelProfile.id)
  return _s;
}
inline const std::string& HotelProfile::_internal_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.id_.Get();
}
inline void HotelProfile::_internal_set_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.Set(value, GetArena());
}
inline std::string* HotelProfile::_internal_mutable_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.id_.Mutable( GetArena());
}
inline std::string* HotelProfile::release_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:hotelreservation.HotelProfile.id)
  return _impl_.id_.Release();
}
inline void HotelProfile::set_allocated_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hotelreservation.HotelProfile.id)
}

// string name = 2;
inline void HotelProfile::clear_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& HotelProfile::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:hotelreservation.HotelProfile.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void HotelProfile::set_name(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:hotelreservation.HotelProfile.name)
}
inline std::string* HotelProfile::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:hotelreservation.HotelProfile.name)
  return _s;
}
inline const std::string& HotelProfile::_internal_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.name_.Get();
}
inline void HotelProfile::_internal_set_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.Set(value, GetArena());
}
inline std::string* HotelProfile::_internal_mutable_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* HotelProfile::release_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:hotelreservation.HotelProfile.name)
  return _impl_.name_.Release();
}
inline void HotelProfile::set_allocated_name(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hotelreservation.HotelProfile.name)
}

// string phone_number = 3;
inline void HotelProfile::clear_phone_number() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.phone_number_.ClearToEmpty();
}
inline const std::string& HotelProfile::phone_number() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:hotelreservation.HotelProfile.phone_number)
  return _internal_phone_number();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void HotelProfile::set_phone_number(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.phone_number_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:hotelreservation.HotelProfile.phone_number)
}
inline std::string* HotelProfile::mutable_phone_number() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_phone_number();
  // @@protoc_insertion_point(field_mutable:hotelreservation.HotelProfile.phone_number)
  return _s;
}
inline const std::string& HotelProfile::_internal_phone_number() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.phone_number_.Get();
}
inline void HotelProfile::_internal_set_phone_number(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.phone_number_.Set(value, GetArena());
}
inline std::string* HotelProfile::_internal_mutable_phone_number() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.phone_number_.Mutable( GetArena());
}
inline std::string* HotelProfile::release_phone_number() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:hotelreservation.HotelProfile.phone_number)
  return _impl_.phone_number_.Release();
}
inline void HotelProfile::set_allocated_phone_number(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.phone_number_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.phone_number_.IsDefault()) {
          _impl_.phone_number_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hotelreservation.HotelProfile.phone_number)
}

// string description = 4;
inline void HotelProfile::clear_description() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.description_.ClearToEmpty();
}
inline const std::string& HotelProfile::description() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:hotelreservation.HotelProfile.description)
  return _internal_description();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void HotelProfile::set_description(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.description_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:hotelreservation.HotelProfile.description)
}
inline std::string* HotelProfile::mutable_description() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:hotelreservation.HotelProfile.description)
  return _s;
}
inline const std::string& HotelProfile::_internal_description() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.description_.Get();
}
inline void HotelProfile::_internal_set_description(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.description_.Set(value, GetArena());
}
inline std::string* HotelProfile::_internal_mutable_description() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.description_.Mutable( GetArena());
}
inline std::string* HotelProfile::release_description() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:hotelreservation.HotelProfile.description)
  return _impl_.description_.Release();
}
inline void HotelProfile::set_allocated_description(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.description_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.description_.IsDefault()) {
          _impl_.description_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hotelreservation.HotelProfile.description)
}

// .hotelreservation.Address address = 5;
inline bool HotelProfile::has_address() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.address_ != nullptr);
  return value;
}
inline void HotelProfile::clear_address() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.address_ != nullptr) _impl_.address_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::hotelreservation::Address& HotelProfile::_internal_address() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::hotelreservation::Address* p = _impl_.address_;
  return p != nullptr ? *p : reinterpret_cast<const ::hotelreservation::Address&>(::hotelreservation::_Address_default_instance_);
}
inline const ::hotelreservation::Address& HotelProfile::address() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:hotelreservation.HotelProfile.address)
  return _internal_address();
}
inline void HotelProfile::unsafe_arena_set_allocated_address(::hotelreservation::Address* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.address_);
  }
  _impl_.address_ = reinterpret_cast<::hotelreservation::Address*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hotelreservation.HotelProfile.address)
}
inline ::hotelreservation::Address* HotelProfile::release_address() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::hotelreservation::Address* released = _impl_.address_;
  _impl_.address_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::hotelreservation::Address* HotelProfile::unsafe_arena_release_address() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:hotelreservation.HotelProfile.address)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::hotelreservation::Address* temp = _impl_.address_;
  _impl_.address_ = nullptr;
  return temp;
}
inline ::hotelreservation::Address* HotelProfile::_internal_mutable_address() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.address_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::hotelreservation::Address>(GetArena());
    _impl_.address_ = reinterpret_cast<::hotelreservation::Address*>(p);
  }
  return _impl_.address_;
}
inline ::hotelreservation::Address* HotelProfile::mutable_address() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::hotelreservation::Address* _msg = _internal_mutable_address();
  // @@protoc_insertion_point(field_mutable:hotelreservation.HotelProfile.address)
  return _msg;
}
inline void HotelProfile::set_allocated_address(::hotelreservation::Address* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.address_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.address_ = reinterpret_cast<::hotelreservation::Address*>(value);
  // @@protoc_insertion_point(field_set_allocated:hotelreservation.HotelProfile.address)
}

// -------------------------------------------------------------------

// SearchRequest

// string customer_name = 1;
inline void SearchRequest::clear_customer_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.customer_name_.ClearToEmpty();
}
inline const std::string& SearchRequest::customer_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:hotelreservation.SearchRequest.customer_name)
  return _internal_customer_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SearchRequest::set_customer_name(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.customer_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:hotelreservation.SearchRequest.customer_name)
}
inline std::string* SearchRequest::mutable_customer_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_customer_name();
  // @@protoc_insertion_point(field_mutable:hotelreservation.SearchRequest.customer_name)
  return _s;
}
inline const std::string& SearchRequest::_internal_customer_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.customer_name_.Get();
}
inline void SearchRequest::_internal_set_customer_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.customer_name_.Set(value, GetArena());
}
inline std::string* SearchRequest::_internal_mutable_customer_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.customer_name_.Mutable( GetArena());
}
inline std::string* SearchRequest::release_customer_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:hotelreservation.SearchRequest.customer_name)
  return _impl_.customer_name_.Release();
}
inline void SearchRequest::set_allocated_customer_name(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.customer_name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.customer_name_.IsDefault()) {
          _impl_.customer_name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hotelreservation.SearchRequest.customer_name)
}

// string in_date = 2;
inline void SearchRequest::clear_in_date() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.in_date_.ClearToEmpty();
}
inline const std::string& SearchRequest::in_date() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:hotelreservation.SearchRequest.in_date)
  return _internal_in_date();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SearchRequest::set_in_date(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.in_date_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:hotelreservation.SearchRequest.in_date)
}
inline std::string* SearchRequest::mutable_in_date() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_in_date();
  // @@protoc_insertion_point(field_mutable:hotelreservation.SearchRequest.in_date)
  return _s;
}
inline const std::string& SearchRequest::_internal_in_date() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.in_date_.Get();
}
inline void SearchRequest::_internal_set_in_date(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.in_date_.Set(value, GetArena());
}
inline std::string* SearchRequest::_internal_mutable_in_date() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.in_date_.Mutable( GetArena());
}
inline std::string* SearchRequest::release_in_date() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:hotelreservation.SearchRequest.in_date)
  return _impl_.in_date_.Release();
}
inline void SearchRequest::set_allocated_in_date(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.in_date_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.in_date_.IsDefault()) {
          _impl_.in_date_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hotelreservation.SearchRequest.in_date)
}

// string out_date = 3;
inline void SearchRequest::clear_out_date() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.out_date_.ClearToEmpty();
}
inline const std::string& SearchRequest::out_date() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:hotelreservation.SearchRequest.out_date)
  return _internal_out_date();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SearchRequest::set_out_date(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.out_date_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:hotelreservation.SearchRequest.out_date)
}
inline std::string* SearchRequest::mutable_out_date() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_out_date();
  // @@protoc_insertion_point(field_mutable:hotelreservation.SearchRequest.out_date)
  return _s;
}
inline const std::string& SearchRequest::_internal_out_date() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.out_date_.Get();
}
inline void SearchRequest::_internal_set_out_date(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.out_date_.Set(value, GetArena());
}
inline std::string* SearchRequest::_internal_mutable_out_date() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.out_date_.Mutable( GetArena());
}
inline std::string* SearchRequest::release_out_date() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:hotelreservation.SearchRequest.out_date)
  return _impl_.out_date_.Release();
}
inline void SearchRequest::set_allocated_out_date(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.out_date_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.out_date_.IsDefault()) {
          _impl_.out_date_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hotelreservation.SearchRequest.out_date)
}

// double lat = 4;
inline void SearchRequest::clear_lat() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.lat_ = 0;
}
inline double SearchRequest::lat() const {
  // @@protoc_insertion_point(field_get:hotelreservation.SearchRequest.lat)
  return _internal_lat();
}
inline void SearchRequest::set_lat(double value) {
  _internal_set_lat(value);
  // @@protoc_insertion_point(field_set:hotelreservation.SearchRequest.lat)
}
inline double SearchRequest::_internal_lat() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.lat_;
}
inline void SearchRequest::_internal_set_lat(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.lat_ = value;
}

// double lon = 5;
inline void SearchRequest::clear_lon() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.lon_ = 0;
}
inline double SearchRequest::lon() const {
  // @@protoc_insertion_point(field_get:hotelreservation.SearchRequest.lon)
  return _internal_lon();
}
inline void SearchRequest::set_lon(double value) {
  _internal_set_lon(value);
  // @@protoc_insertion_point(field_set:hotelreservation.SearchRequest.lon)
}
inline double SearchRequest::_internal_lon() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.lon_;
}
inline void SearchRequest::_internal_set_lon(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.lon_ = value;
}

// string locale = 6;
inline void SearchRequest::clear_locale() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.locale_.ClearToEmpty();
}
inline const std::string& SearchRequest::locale() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:hotelreservation.SearchRequest.locale)
  return _internal_locale();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SearchRequest::set_locale(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.locale_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:hotelreservation.SearchRequest.locale)
}
inline std::string* SearchRequest::mutable_locale() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_locale();
  // @@protoc_insertion_point(field_mutable:hotelreservation.SearchRequest.locale)
  return _s;
}
inline const std::string& SearchRequest::_internal_locale() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.locale_.Get();
}
inline void SearchRequest::_internal_set_locale(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.locale_.Set(value, GetArena());
}
inline std::string* SearchRequest::_internal_mutable_locale() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.locale_.Mutable( GetArena());
}
inline std::string* SearchRequest::release_locale() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:hotelreservation.SearchRequest.locale)
  return _impl_.locale_.Release();
}
inline void SearchRequest::set_allocated_locale(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.locale_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.locale_.IsDefault()) {
          _impl_.locale_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hotelreservation.SearchRequest.locale)
}

// -------------------------------------------------------------------

// SearchResponse

// repeated .hotelreservation.HotelProfile hotels = 1;
inline int SearchResponse::_internal_hotels_size() const {
  return _internal_hotels().size();
}
inline int SearchResponse::hotels_size() const {
  return _internal_hotels_size();
}
inline void SearchResponse::clear_hotels() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.hotels_.Clear();
}
inline ::hotelreservation::HotelProfile* SearchResponse::mutable_hotels(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:hotelreservation.SearchResponse.hotels)
  return _internal_mutable_hotels()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::hotelreservation::HotelProfile>* SearchResponse::mutable_hotels()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:hotelreservation.SearchResponse.hotels)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_hotels();
}
inline const ::hotelreservation::HotelProfile& SearchResponse::hotels(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:hotelreservation.SearchResponse.hotels)
  return _internal_hotels().Get(index);
}
inline ::hotelreservation::HotelProfile* SearchResponse::add_hotels() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::hotelreservation::HotelProfile* _add = _internal_mutable_hotels()->Add();
  // @@protoc_insertion_point(field_add:hotelreservation.SearchResponse.hotels)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::hotelreservation::HotelProfile>& SearchResponse::hotels() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:hotelreservation.SearchResponse.hotels)
  return _internal_hotels();
}
inline const ::google::protobuf::RepeatedPtrField<::hotelreservation::HotelProfile>&
SearchResponse::_internal_hotels() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.hotels_;
}
inline ::google::protobuf::RepeatedPtrField<::hotelreservation::HotelProfile>*
SearchResponse::_internal_mutable_hotels() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.hotels_;
}

// -------------------------------------------------------------------

// RecommendRequest

// double lat = 1;
inline void RecommendRequest::clear_lat() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.lat_ = 0;
}
inline double RecommendRequest::lat() const {
  // @@protoc_insertion_point(field_get:hotelreservation.RecommendRequest.lat)
  return _internal_lat();
}
inline void RecommendRequest::set_lat(double value) {
  _internal_set_lat(value);
  // @@protoc_insertion_point(field_set:hotelreservation.RecommendRequest.lat)
}
inline double RecommendRequest::_internal_lat() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.lat_;
}
inline void RecommendRequest::_internal_set_lat(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.lat_ = value;
}

// double lon = 2;
inline void RecommendRequest::clear_lon() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.lon_ = 0;
}
inline double RecommendRequest::lon() const {
  // @@protoc_insertion_point(field_get:hotelreservation.RecommendRequest.lon)
  return _internal_lon();
}
inline void RecommendRequest::set_lon(double value) {
  _internal_set_lon(value);
  // @@protoc_insertion_point(field_set:hotelreservation.RecommendRequest.lon)
}
inline double RecommendRequest::_internal_lon() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.lon_;
}
inline void RecommendRequest::_internal_set_lon(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.lon_ = value;
}

// string require = 3;
inline void RecommendRequest::clear_require() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.require_.ClearToEmpty();
}
inline const std::string& RecommendRequest::require() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:hotelreservation.RecommendRequest.require)
  return _internal_require();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RecommendRequest::set_require(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.require_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:hotelreservation.RecommendRequest.require)
}
inline std::string* RecommendRequest::mutable_require() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_require();
  // @@protoc_insertion_point(field_mutable:hotelreservation.RecommendRequest.require)
  return _s;
}
inline const std::string& RecommendRequest::_internal_require() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.require_.Get();
}
inline void RecommendRequest::_internal_set_require(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.require_.Set(value, GetArena());
}
inline std::string* RecommendRequest::_internal_mutable_require() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.require_.Mutable( GetArena());
}
inline std::string* RecommendRequest::release_require() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:hotelreservation.RecommendRequest.require)
  return _impl_.require_.Release();
}
inline void RecommendRequest::set_allocated_require(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.require_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.require_.IsDefault()) {
          _impl_.require_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hotelreservation.RecommendRequest.require)
}

// string locale = 4;
inline void RecommendRequest::clear_locale() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.locale_.ClearToEmpty();
}
inline const std::string& RecommendRequest::locale() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:hotelreservation.RecommendRequest.locale)
  return _internal_locale();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RecommendRequest::set_locale(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.locale_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:hotelreservation.RecommendRequest.locale)
}
inline std::string* RecommendRequest::mutable_locale() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_locale();
  // @@protoc_insertion_point(field_mutable:hotelreservation.RecommendRequest.locale)
  return _s;
}
inline const std::string& RecommendRequest::_internal_locale() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.locale_.Get();
}
inline void RecommendRequest::_internal_set_locale(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.locale_.Set(value, GetArena());
}
inline std::string* RecommendRequest::_internal_mutable_locale() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.locale_.Mutable( GetArena());
}
inline std::string* RecommendRequest::release_locale() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:hotelreservation.RecommendRequest.locale)
  return _impl_.locale_.Release();
}
inline void RecommendRequest::set_allocated_locale(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.locale_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.locale_.IsDefault()) {
          _impl_.locale_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hotelreservation.RecommendRequest.locale)
}

// -------------------------------------------------------------------

// RecommendResponse

// repeated .hotelreservation.HotelProfile hotels = 1;
inline int RecommendResponse::_internal_hotels_size() const {
  return _internal_hotels().size();
}
inline int RecommendResponse::hotels_size() const {
  return _internal_hotels_size();
}
inline void RecommendResponse::clear_hotels() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.hotels_.Clear();
}
inline ::hotelreservation::HotelProfile* RecommendResponse::mutable_hotels(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:hotelreservation.RecommendResponse.hotels)
  return _internal_mutable_hotels()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::hotelreservation::HotelProfile>* RecommendResponse::mutable_hotels()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:hotelreservation.RecommendResponse.hotels)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_hotels();
}
inline const ::hotelreservation::HotelProfile& RecommendResponse::hotels(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:hotelreservation.RecommendResponse.hotels)
  return _internal_hotels().Get(index);
}
inline ::hotelreservation::HotelProfile* RecommendResponse::add_hotels() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::hotelreservation::HotelProfile* _add = _internal_mutable_hotels()->Add();
  // @@protoc_insertion_point(field_add:hotelreservation.RecommendResponse.hotels)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::hotelreservation::HotelProfile>& RecommendResponse::hotels() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:hotelreservation.RecommendResponse.hotels)
  return _internal_hotels();
}
inline const ::google::protobuf::RepeatedPtrField<::hotelreservation::HotelProfile>&
RecommendResponse::_internal_hotels() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.hotels_;
}
inline ::google::protobuf::RepeatedPtrField<::hotelreservation::HotelProfile>*
RecommendResponse::_internal_mutable_hotels() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.hotels_;
}

// -------------------------------------------------------------------

// UserRequest

// string username = 1;
inline void UserRequest::clear_username() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.username_.ClearToEmpty();
}
inline const std::string& UserRequest::username() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:hotelreservation.UserRequest.username)
  return _internal_username();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UserRequest::set_username(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.username_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:hotelreservation.UserRequest.username)
}
inline std::string* UserRequest::mutable_username() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:hotelreservation.UserRequest.username)
  return _s;
}
inline const std::string& UserRequest::_internal_username() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.username_.Get();
}
inline void UserRequest::_internal_set_username(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.username_.Set(value, GetArena());
}
inline std::string* UserRequest::_internal_mutable_username() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.username_.Mutable( GetArena());
}
inline std::string* UserRequest::release_username() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:hotelreservation.UserRequest.username)
  return _impl_.username_.Release();
}
inline void UserRequest::set_allocated_username(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.username_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.username_.IsDefault()) {
          _impl_.username_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hotelreservation.UserRequest.username)
}

// string password = 2;
inline void UserRequest::clear_password() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.password_.ClearToEmpty();
}
inline const std::string& UserRequest::password() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:hotelreservation.UserRequest.password)
  return _internal_password();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UserRequest::set_password(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.password_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:hotelreservation.UserRequest.password)
}
inline std::string* UserRequest::mutable_password() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:hotelreservation.UserRequest.password)
  return _s;
}
inline const std::string& UserRequest::_internal_password() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.password_.Get();
}
inline void UserRequest::_internal_set_password(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.password_.Set(value, GetArena());
}
inline std::string* UserRequest::_internal_mutable_password() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.password_.Mutable( GetArena());
}
inline std::string* UserRequest::release_password() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:hotelreservation.UserRequest.password)
  return _impl_.password_.Release();
}
inline void UserRequest::set_allocated_password(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.password_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.password_.IsDefault()) {
          _impl_.password_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hotelreservation.UserRequest.password)
}

// -------------------------------------------------------------------

// UserResponse

// string message = 1;
inline void UserResponse::clear_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.message_.ClearToEmpty();
}
inline const std::string& UserResponse::message() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:hotelreservation.UserResponse.message)
  return _internal_message();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UserResponse::set_message(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.message_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:hotelreservation.UserResponse.message)
}
inline std::string* UserResponse::mutable_message() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:hotelreservation.UserResponse.message)
  return _s;
}
inline const std::string& UserResponse::_internal_message() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.message_.Get();
}
inline void UserResponse::_internal_set_message(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.message_.Set(value, GetArena());
}
inline std::string* UserResponse::_internal_mutable_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.message_.Mutable( GetArena());
}
inline std::string* UserResponse::release_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:hotelreservation.UserResponse.message)
  return _impl_.message_.Release();
}
inline void UserResponse::set_allocated_message(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.message_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.message_.IsDefault()) {
          _impl_.message_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hotelreservation.UserResponse.message)
}

// -------------------------------------------------------------------

// ReservationRequest

// string in_date = 1;
inline void ReservationRequest::clear_in_date() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.in_date_.ClearToEmpty();
}
inline const std::string& ReservationRequest::in_date() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:hotelreservation.ReservationRequest.in_date)
  return _internal_in_date();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ReservationRequest::set_in_date(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.in_date_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:hotelreservation.ReservationRequest.in_date)
}
inline std::string* ReservationRequest::mutable_in_date() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_in_date();
  // @@protoc_insertion_point(field_mutable:hotelreservation.ReservationRequest.in_date)
  return _s;
}
inline const std::string& ReservationRequest::_internal_in_date() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.in_date_.Get();
}
inline void ReservationRequest::_internal_set_in_date(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.in_date_.Set(value, GetArena());
}
inline std::string* ReservationRequest::_internal_mutable_in_date() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.in_date_.Mutable( GetArena());
}
inline std::string* ReservationRequest::release_in_date() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:hotelreservation.ReservationRequest.in_date)
  return _impl_.in_date_.Release();
}
inline void ReservationRequest::set_allocated_in_date(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.in_date_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.in_date_.IsDefault()) {
          _impl_.in_date_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hotelreservation.ReservationRequest.in_date)
}

// string out_date = 2;
inline void ReservationRequest::clear_out_date() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.out_date_.ClearToEmpty();
}
inline const std::string& ReservationRequest::out_date() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:hotelreservation.ReservationRequest.out_date)
  return _internal_out_date();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ReservationRequest::set_out_date(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.out_date_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:hotelreservation.ReservationRequest.out_date)
}
inline std::string* ReservationRequest::mutable_out_date() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_out_date();
  // @@protoc_insertion_point(field_mutable:hotelreservation.ReservationRequest.out_date)
  return _s;
}
inline const std::string& ReservationRequest::_internal_out_date() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.out_date_.Get();
}
inline void ReservationRequest::_internal_set_out_date(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.out_date_.Set(value, GetArena());
}
inline std::string* ReservationRequest::_internal_mutable_out_date() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.out_date_.Mutable( GetArena());
}
inline std::string* ReservationRequest::release_out_date() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:hotelreservation.ReservationRequest.out_date)
  return _impl_.out_date_.Release();
}
inline void ReservationRequest::set_allocated_out_date(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.out_date_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.out_date_.IsDefault()) {
          _impl_.out_date_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hotelreservation.ReservationRequest.out_date)
}

// string hotel_id = 3;
inline void ReservationRequest::clear_hotel_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.hotel_id_.ClearToEmpty();
}
inline const std::string& ReservationRequest::hotel_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:hotelreservation.ReservationRequest.hotel_id)
  return _internal_hotel_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ReservationRequest::set_hotel_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.hotel_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:hotelreservation.ReservationRequest.hotel_id)
}
inline std::string* ReservationRequest::mutable_hotel_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_hotel_id();
  // @@protoc_insertion_point(field_mutable:hotelreservation.ReservationRequest.hotel_id)
  return _s;
}
inline const std::string& ReservationRequest::_internal_hotel_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.hotel_id_.Get();
}
inline void ReservationRequest::_internal_set_hotel_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.hotel_id_.Set(value, GetArena());
}
inline std::string* ReservationRequest::_internal_mutable_hotel_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.hotel_id_.Mutable( GetArena());
}
inline std::string* ReservationRequest::release_hotel_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:hotelreservation.ReservationRequest.hotel_id)
  return _impl_.hotel_id_.Release();
}
inline void ReservationRequest::set_allocated_hotel_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.hotel_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.hotel_id_.IsDefault()) {
          _impl_.hotel_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hotelreservation.ReservationRequest.hotel_id)
}

// string customer_name = 4;
inline void ReservationRequest::clear_customer_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.customer_name_.ClearToEmpty();
}
inline const std::string& ReservationRequest::customer_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:hotelreservation.ReservationRequest.customer_name)
  return _internal_customer_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ReservationRequest::set_customer_name(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.customer_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:hotelreservation.ReservationRequest.customer_name)
}
inline std::string* ReservationRequest::mutable_customer_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_customer_name();
  // @@protoc_insertion_point(field_mutable:hotelreservation.ReservationRequest.customer_name)
  return _s;
}
inline const std::string& ReservationRequest::_internal_customer_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.customer_name_.Get();
}
inline void ReservationRequest::_internal_set_customer_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.customer_name_.Set(value, GetArena());
}
inline std::string* ReservationRequest::_internal_mutable_customer_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.customer_name_.Mutable( GetArena());
}
inline std::string* ReservationRequest::release_customer_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:hotelreservation.ReservationRequest.customer_name)
  return _impl_.customer_name_.Release();
}
inline void ReservationRequest::set_allocated_customer_name(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.customer_name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.customer_name_.IsDefault()) {
          _impl_.customer_name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hotelreservation.ReservationRequest.customer_name)
}

// string username = 5;
inline void ReservationRequest::clear_username() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.username_.ClearToEmpty();
}
inline const std::string& ReservationRequest::username() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:hotelreservation.ReservationRequest.username)
  return _internal_username();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ReservationRequest::set_username(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.username_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:hotelreservation.ReservationRequest.username)
}
inline std::string* ReservationRequest::mutable_username() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:hotelreservation.ReservationRequest.username)
  return _s;
}
inline const std::string& ReservationRequest::_internal_username() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.username_.Get();
}
inline void ReservationRequest::_internal_set_username(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.username_.Set(value, GetArena());
}
inline std::string* ReservationRequest::_internal_mutable_username() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.username_.Mutable( GetArena());
}
inline std::string* ReservationRequest::release_username() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:hotelreservation.ReservationRequest.username)
  return _impl_.username_.Release();
}
inline void ReservationRequest::set_allocated_username(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.username_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.username_.IsDefault()) {
          _impl_.username_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hotelreservation.ReservationRequest.username)
}

// string password = 6;
inline void ReservationRequest::clear_password() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.password_.ClearToEmpty();
}
inline const std::string& ReservationRequest::password() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:hotelreservation.ReservationRequest.password)
  return _internal_password();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ReservationRequest::set_password(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.password_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:hotelreservation.ReservationRequest.password)
}
inline std::string* ReservationRequest::mutable_password() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:hotelreservation.ReservationRequest.password)
  return _s;
}
inline const std::string& ReservationRequest::_internal_password() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.password_.Get();
}
inline void ReservationRequest::_internal_set_password(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.password_.Set(value, GetArena());
}
inline std::string* ReservationRequest::_internal_mutable_password() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.password_.Mutable( GetArena());
}
inline std::string* ReservationRequest::release_password() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:hotelreservation.ReservationRequest.password)
  return _impl_.password_.Release();
}
inline void ReservationRequest::set_allocated_password(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.password_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.password_.IsDefault()) {
          _impl_.password_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hotelreservation.ReservationRequest.password)
}

// int64 room_number = 7;
inline void ReservationRequest::clear_room_number() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.room_number_ = ::int64_t{0};
}
inline ::int64_t ReservationRequest::room_number() const {
  // @@protoc_insertion_point(field_get:hotelreservation.ReservationRequest.room_number)
  return _internal_room_number();
}
inline void ReservationRequest::set_room_number(::int64_t value) {
  _internal_set_room_number(value);
  // @@protoc_insertion_point(field_set:hotelreservation.ReservationRequest.room_number)
}
inline ::int64_t ReservationRequest::_internal_room_number() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.room_number_;
}
inline void ReservationRequest::_internal_set_room_number(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.room_number_ = value;
}

// -------------------------------------------------------------------

// ReservationResponse

// string message = 1;
inline void ReservationResponse::clear_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.message_.ClearToEmpty();
}
inline const std::string& ReservationResponse::message() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:hotelreservation.ReservationResponse.message)
  return _internal_message();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ReservationResponse::set_message(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.message_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:hotelreservation.ReservationResponse.message)
}
inline std::string* ReservationResponse::mutable_message() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:hotelreservation.ReservationResponse.message)
  return _s;
}
inline const std::string& ReservationResponse::_internal_message() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.message_.Get();
}
inline void ReservationResponse::_internal_set_message(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.message_.Set(value, GetArena());
}
inline std::string* ReservationResponse::_internal_mutable_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.message_.Mutable( GetArena());
}
inline std::string* ReservationResponse::release_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:hotelreservation.ReservationResponse.message)
  return _impl_.message_.Release();
}
inline void ReservationResponse::set_allocated_message(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.message_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.message_.IsDefault()) {
          _impl_.message_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hotelreservation.ReservationResponse.message)
}

// -------------------------------------------------------------------

// NearbyRequest

// double lat = 1;
inline void NearbyRequest::clear_lat() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.lat_ = 0;
}
inline double NearbyRequest::lat() const {
  // @@protoc_insertion_point(field_get:hotelreservation.NearbyRequest.lat)
  return _internal_lat();
}
inline void NearbyRequest::set_lat(double value) {
  _internal_set_lat(value);
  // @@protoc_insertion_point(field_set:hotelreservation.NearbyRequest.lat)
}
inline double NearbyRequest::_internal_lat() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.lat_;
}
inline void NearbyRequest::_internal_set_lat(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.lat_ = value;
}

// double lon = 2;
inline void NearbyRequest::clear_lon() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.lon_ = 0;
}
inline double NearbyRequest::lon() const {
  // @@protoc_insertion_point(field_get:hotelreservation.NearbyRequest.lon)
  return _internal_lon();
}
inline void NearbyRequest::set_lon(double value) {
  _internal_set_lon(value);
  // @@protoc_insertion_point(field_set:hotelreservation.NearbyRequest.lon)
}
inline double NearbyRequest::_internal_lon() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.lon_;
}
inline void NearbyRequest::_internal_set_lon(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.lon_ = value;
}

// -------------------------------------------------------------------

// NearbyResponse

// repeated string hotel_ids = 1;
inline int NearbyResponse::_internal_hotel_ids_size() const {
  return _internal_hotel_ids().size();
}
inline int NearbyResponse::hotel_ids_size() const {
  return _internal_hotel_ids_size();
}
inline void NearbyResponse::clear_hotel_ids() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.hotel_ids_.Clear();
}
inline std::string* NearbyResponse::add_hotel_ids()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  std::string* _s = _internal_mutable_hotel_ids()->Add();
  // @@protoc_insertion_point(field_add_mutable:hotelreservation.NearbyResponse.hotel_ids)
  return _s;
}
inline const std::string& NearbyResponse::hotel_ids(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:hotelreservation.NearbyResponse.hotel_ids)
  return _internal_hotel_ids().Get(index);
}
inline std::string* NearbyResponse::mutable_hotel_ids(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:hotelreservation.NearbyResponse.hotel_ids)
  return _internal_mutable_hotel_ids()->Mutable(index);
}
inline void NearbyResponse::set_hotel_ids(int index, const std::string& value) {
  _internal_mutable_hotel_ids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:hotelreservation.NearbyResponse.hotel_ids)
}
inline void NearbyResponse::set_hotel_ids(int index, std::string&& value) {
  _internal_mutable_hotel_ids()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:hotelreservation.NearbyResponse.hotel_ids)
}
inline void NearbyResponse::set_hotel_ids(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_hotel_ids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:hotelreservation.NearbyResponse.hotel_ids)
}
inline void NearbyResponse::set_hotel_ids(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_hotel_ids()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:hotelreservation.NearbyResponse.hotel_ids)
}
inline void NearbyResponse::set_hotel_ids(int index, absl::string_view value) {
  _internal_mutable_hotel_ids()->Mutable(index)->assign(
      value.data(), value.size());
  // @@protoc_insertion_point(field_set_string_piece:hotelreservation.NearbyResponse.hotel_ids)
}
inline void NearbyResponse::add_hotel_ids(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_hotel_ids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:hotelreservation.NearbyResponse.hotel_ids)
}
inline void NearbyResponse::add_hotel_ids(std::string&& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_hotel_ids()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:hotelreservation.NearbyResponse.hotel_ids)
}
inline void NearbyResponse::add_hotel_ids(const char* value) {
  ABSL_DCHECK(value != nullptr);
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_hotel_ids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:hotelreservation.NearbyResponse.hotel_ids)
}
inline void NearbyResponse::add_hotel_ids(const char* value, std::size_t size) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_hotel_ids()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:hotelreservation.NearbyResponse.hotel_ids)
}
inline void NearbyResponse::add_hotel_ids(absl::string_view value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_hotel_ids()->Add()->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_add_string_piece:hotelreservation.NearbyResponse.hotel_ids)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
NearbyResponse::hotel_ids() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:hotelreservation.NearbyResponse.hotel_ids)
  return _internal_hotel_ids();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
NearbyResponse::mutable_hotel_ids() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:hotelreservation.NearbyResponse.hotel_ids)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_hotel_ids();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
NearbyResponse::_internal_hotel_ids() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.hotel_ids_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
NearbyResponse::_internal_mutable_hotel_ids() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.hotel_ids_;
}

// -------------------------------------------------------------------

// GetProfilesRequest

// repeated string hotel_ids = 1;
inline int GetProfilesRequest::_internal_hotel_ids_size() const {
  return _internal_hotel_ids().size();
}
inline int GetProfilesRequest::hotel_ids_size() const {
  return _internal_hotel_ids_size();
}
inline void GetProfilesRequest::clear_hotel_ids() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.hotel_ids_.Clear();
}
inline std::string* GetProfilesRequest::add_hotel_ids()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  std::string* _s = _internal_mutable_hotel_ids()->Add();
  // @@protoc_insertion_point(field_add_mutable:hotelreservation.GetProfilesRequest.hotel_ids)
  return _s;
}
inline const std::string& GetProfilesRequest::hotel_ids(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:hotelreservation.GetProfilesRequest.hotel_ids)
  return _internal_hotel_ids().Get(index);
}
inline std::string* GetProfilesRequest::mutable_hotel_ids(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:hotelreservation.GetProfilesRequest.hotel_ids)
  return _internal_mutable_hotel_ids()->Mutable(index);
}
inline void GetProfilesRequest::set_hotel_ids(int index, const std::string& value) {
  _internal_mutable_hotel_ids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:hotelreservation.GetProfilesRequest.hotel_ids)
}
inline void GetProfilesRequest::set_hotel_ids(int index, std::string&& value) {
  _internal_mutable_hotel_ids()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:hotelreservation.GetProfilesRequest.hotel_ids)
}
inline void GetProfilesRequest::set_hotel_ids(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_hotel_ids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:hotelreservation.GetProfilesRequest.hotel_ids)
}
inline void GetProfilesRequest::set_hotel_ids(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_hotel_ids()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:hotelreservation.GetProfilesRequest.hotel_ids)
}
inline void GetProfilesRequest::set_hotel_ids(int index, absl::string_view value) {
  _internal_mutable_hotel_ids()->Mutable(index)->assign(
      value.data(), value.size());
  // @@protoc_insertion_point(field_set_string_piece:hotelreservation.GetProfilesRequest.hotel_ids)
}
inline void GetProfilesRequest::add_hotel_ids(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_hotel_ids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:hotelreservation.GetProfilesRequest.hotel_ids)
}
inline void GetProfilesRequest::add_hotel_ids(std::string&& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_hotel_ids()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:hotelreservation.GetProfilesRequest.hotel_ids)
}
inline void GetProfilesRequest::add_hotel_ids(const char* value) {
  ABSL_DCHECK(value != nullptr);
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_hotel_ids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:hotelreservation.GetProfilesRequest.hotel_ids)
}
inline void GetProfilesRequest::add_hotel_ids(const char* value, std::size_t size) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_hotel_ids()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:hotelreservation.GetProfilesRequest.hotel_ids)
}
inline void GetProfilesRequest::add_hotel_ids(absl::string_view value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_hotel_ids()->Add()->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_add_string_piece:hotelreservation.GetProfilesRequest.hotel_ids)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
GetProfilesRequest::hotel_ids() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:hotelreservation.GetProfilesRequest.hotel_ids)
  return _internal_hotel_ids();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
GetProfilesRequest::mutable_hotel_ids() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:hotelreservation.GetProfilesRequest.hotel_ids)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_hotel_ids();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
GetProfilesRequest::_internal_hotel_ids() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.hotel_ids_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
GetProfilesRequest::_internal_mutable_hotel_ids() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.hotel_ids_;
}

// string locale = 2;
inline void GetProfilesRequest::clear_locale() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.locale_.ClearToEmpty();
}
inline const std::string& GetProfilesRequest::locale() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:hotelreservation.GetProfilesRequest.locale)
  return _internal_locale();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetProfilesRequest::set_locale(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.locale_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:hotelreservation.GetProfilesRequest.locale)
}
inline std::string* GetProfilesRequest::mutable_locale() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_locale();
  // @@protoc_insertion_point(field_mutable:hotelreservation.GetProfilesRequest.locale)
  return _s;
}
inline const std::string& GetProfilesRequest::_internal_locale() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.locale_.Get();
}
inline void GetProfilesRequest::_internal_set_locale(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.locale_.Set(value, GetArena());
}
inline std::string* GetProfilesRequest::_internal_mutable_locale() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.locale_.Mutable( GetArena());
}
inline std::string* GetProfilesRequest::release_locale() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:hotelreservation.GetProfilesRequest.locale)
  return _impl_.locale_.Release();
}
inline void GetProfilesRequest::set_allocated_locale(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.locale_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.locale_.IsDefault()) {
          _impl_.locale_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hotelreservation.GetProfilesRequest.locale)
}

// -------------------------------------------------------------------

// GetProfilesResponse

// repeated .hotelreservation.HotelProfile profiles = 1;
inline int GetProfilesResponse::_internal_profiles_size() const {
  return _internal_profiles().size();
}
inline int GetProfilesResponse::profiles_size() const {
  return _internal_profiles_size();
}
inline void GetProfilesResponse::clear_profiles() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.profiles_.Clear();
}
inline ::hotelreservation::HotelProfile* GetProfilesResponse::mutable_profiles(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:hotelreservation.GetProfilesResponse.profiles)
  return _internal_mutable_profiles()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::hotelreservation::HotelProfile>* GetProfilesResponse::mutable_profiles()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:hotelreservation.GetProfilesResponse.profiles)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_profiles();
}
inline const ::hotelreservation::HotelProfile& GetProfilesResponse::profiles(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:hotelreservation.GetProfilesResponse.profiles)
  return _internal_profiles().Get(index);
}
inline ::hotelreservation::HotelProfile* GetProfilesResponse::add_profiles() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::hotelreservation::HotelProfile* _add = _internal_mutable_profiles()->Add();
  // @@protoc_insertion_point(field_add:hotelreservation.GetProfilesResponse.profiles)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::hotelreservation::HotelProfile>& GetProfilesResponse::profiles() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:hotelreservation.GetProfilesResponse.profiles)
  return _internal_profiles();
}
inline const ::google::protobuf::RepeatedPtrField<::hotelreservation::HotelProfile>&
GetProfilesResponse::_internal_profiles() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.profiles_;
}
inline ::google::protobuf::RepeatedPtrField<::hotelreservation::HotelProfile>*
GetProfilesResponse::_internal_mutable_profiles() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.profiles_;
}

// -------------------------------------------------------------------

// GetRatesRequest

// repeated string hotel_ids = 1;
inline int GetRatesRequest::_internal_hotel_ids_size() const {
  return _internal_hotel_ids().size();
}
inline int GetRatesRequest::hotel_ids_size() const {
  return _internal_hotel_ids_size();
}
inline void GetRatesRequest::clear_hotel_ids() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.hotel_ids_.Clear();
}
inline std::string* GetRatesRequest::add_hotel_ids()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  std::string* _s = _internal_mutable_hotel_ids()->Add();
  // @@protoc_insertion_point(field_add_mutable:hotelreservation.GetRatesRequest.hotel_ids)
  return _s;
}
inline const std::string& GetRatesRequest::hotel_ids(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:hotelreservation.GetRatesRequest.hotel_ids)
  return _internal_hotel_ids().Get(index);
}
inline std::string* GetRatesRequest::mutable_hotel_ids(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:hotelreservation.GetRatesRequest.hotel_ids)
  return _internal_mutable_hotel_ids()->Mutable(index);
}
inline void GetRatesRequest::set_hotel_ids(int index, const std::string& value) {
  _internal_mutable_hotel_ids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:hotelreservation.GetRatesRequest.hotel_ids)
}
inline void GetRatesRequest::set_hotel_ids(int index, std::string&& value) {
  _internal_mutable_hotel_ids()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:hotelreservation.GetRatesRequest.hotel_ids)
}
inline void GetRatesRequest::set_hotel_ids(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_hotel_ids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:hotelreservation.GetRatesRequest.hotel_ids)
}
inline void GetRatesRequest::set_hotel_ids(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_hotel_ids()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:hotelreservation.GetRatesRequest.hotel_ids)
}
inline void GetRatesRequest::set_hotel_ids(int index, absl::string_view value) {
  _internal_mutable_hotel_ids()->Mutable(index)->assign(
      value.data(), value.size());
  // @@protoc_insertion_point(field_set_string_piece:hotelreservation.GetRatesRequest.hotel_ids)
}
inline void GetRatesRequest::add_hotel_ids(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_hotel_ids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:hotelreservation.GetRatesRequest.hotel_ids)
}
inline void GetRatesRequest::add_hotel_ids(std::string&& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_hotel_ids()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:hotelreservation.GetRatesRequest.hotel_ids)
}
inline void GetRatesRequest::add_hotel_ids(const char* value) {
  ABSL_DCHECK(value != nullptr);
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_hotel_ids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:hotelreservation.GetRatesRequest.hotel_ids)
}
inline void GetRatesRequest::add_hotel_ids(const char* value, std::size_t size) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_hotel_ids()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:hotelreservation.GetRatesRequest.hotel_ids)
}
inline void GetRatesRequest::add_hotel_ids(absl::string_view value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_hotel_ids()->Add()->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_add_string_piece:hotelreservation.GetRatesRequest.hotel_ids)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
GetRatesRequest::hotel_ids() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:hotelreservation.GetRatesRequest.hotel_ids)
  return _internal_hotel_ids();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
GetRatesRequest::mutable_hotel_ids() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:hotelreservation.GetRatesRequest.hotel_ids)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_hotel_ids();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
GetRatesRequest::_internal_hotel_ids() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.hotel_ids_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
GetRatesRequest::_internal_mutable_hotel_ids() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.hotel_ids_;
}

// string in_date = 2;
inline void GetRatesRequest::clear_in_date() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.in_date_.ClearToEmpty();
}
inline const std::string& GetRatesRequest::in_date() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:hotelreservation.GetRatesRequest.in_date)
  return _internal_in_date();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetRatesRequest::set_in_date(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.in_date_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:hotelreservation.GetRatesRequest.in_date)
}
inline std::string* GetRatesRequest::mutable_in_date() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_in_date();
  // @@protoc_insertion_point(field_mutable:hotelreservation.GetRatesRequest.in_date)
  return _s;
}
inline const std::string& GetRatesRequest::_internal_in_date() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.in_date_.Get();
}
inline void GetRatesRequest::_internal_set_in_date(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.in_date_.Set(value, GetArena());
}
inline std::string* GetRatesRequest::_internal_mutable_in_date() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.in_date_.Mutable( GetArena());
}
inline std::string* GetRatesRequest::release_in_date() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:hotelreservation.GetRatesRequest.in_date)
  return _impl_.in_date_.Release();
}
inline void GetRatesRequest::set_allocated_in_date(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.in_date_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.in_date_.IsDefault()) {
          _impl_.in_date_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hotelreservation.GetRatesRequest.in_date)
}

// string out_date = 3;
inline void GetRatesRequest::clear_out_date() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.out_date_.ClearToEmpty();
}
inline const std::string& GetRatesRequest::out_date() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:hotelreservation.GetRatesRequest.out_date)
  return _internal_out_date();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetRatesRequest::set_out_date(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.out_date_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:hotelreservation.GetRatesRequest.out_date)
}
inline std::string* GetRatesRequest::mutable_out_date() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_out_date();
  // @@protoc_insertion_point(field_mutable:hotelreservation.GetRatesRequest.out_date)
  return _s;
}
inline const std::string& GetRatesRequest::_internal_out_date() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.out_date_.Get();
}
inline void GetRatesRequest::_internal_set_out_date(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.out_date_.Set(value, GetArena());
}
inline std::string* GetRatesRequest::_internal_mutable_out_date() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.out_date_.Mutable( GetArena());
}
inline std::string* GetRatesRequest::release_out_date() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:hotelreservation.GetRatesRequest.out_date)
  return _impl_.out_date_.Release();
}
inline void GetRatesRequest::set_allocated_out_date(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.out_date_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.out_date_.IsDefault()) {
          _impl_.out_date_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hotelreservation.GetRatesRequest.out_date)
}

// -------------------------------------------------------------------

// GetRatesResponse

// repeated .hotelreservation.RatePlan rate_plans = 1;
inline int GetRatesResponse::_internal_rate_plans_size() const {
  return _internal_rate_plans().size();
}
inline int GetRatesResponse::rate_plans_size() const {
  return _internal_rate_plans_size();
}
inline void GetRatesResponse::clear_rate_plans() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.rate_plans_.Clear();
}
inline ::hotelreservation::RatePlan* GetRatesResponse::mutable_rate_plans(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:hotelreservation.GetRatesResponse.rate_plans)
  return _internal_mutable_rate_plans()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::hotelreservation::RatePlan>* GetRatesResponse::mutable_rate_plans()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:hotelreservation.GetRatesResponse.rate_plans)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_rate_plans();
}
inline const ::hotelreservation::RatePlan& GetRatesResponse::rate_plans(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:hotelreservation.GetRatesResponse.rate_plans)
  return _internal_rate_plans().Get(index);
}
inline ::hotelreservation::RatePlan* GetRatesResponse::add_rate_plans() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::hotelreservation::RatePlan* _add = _internal_mutable_rate_plans()->Add();
  // @@protoc_insertion_point(field_add:hotelreservation.GetRatesResponse.rate_plans)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::hotelreservation::RatePlan>& GetRatesResponse::rate_plans() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:hotelreservation.GetRatesResponse.rate_plans)
  return _internal_rate_plans();
}
inline const ::google::protobuf::RepeatedPtrField<::hotelreservation::RatePlan>&
GetRatesResponse::_internal_rate_plans() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.rate_plans_;
}
inline ::google::protobuf::RepeatedPtrField<::hotelreservation::RatePlan>*
GetRatesResponse::_internal_mutable_rate_plans() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.rate_plans_;
}

// -------------------------------------------------------------------

// CheckUserRequest

// string username = 1;
inline void CheckUserRequest::clear_username() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.username_.ClearToEmpty();
}
inline const std::string& CheckUserRequest::username() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:hotelreservation.CheckUserRequest.username)
  return _internal_username();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CheckUserRequest::set_username(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.username_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:hotelreservation.CheckUserRequest.username)
}
inline std::string* CheckUserRequest::mutable_username() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:hotelreservation.CheckUserRequest.username)
  return _s;
}
inline const std::string& CheckUserRequest::_internal_username() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.username_.Get();
}
inline void CheckUserRequest::_internal_set_username(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.username_.Set(value, GetArena());
}
inline std::string* CheckUserRequest::_internal_mutable_username() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.username_.Mutable( GetArena());
}
inline std::string* CheckUserRequest::release_username() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:hotelreservation.CheckUserRequest.username)
  return _impl_.username_.Release();
}
inline void CheckUserRequest::set_allocated_username(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.username_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.username_.IsDefault()) {
          _impl_.username_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hotelreservation.CheckUserRequest.username)
}

// string password = 2;
inline void CheckUserRequest::clear_password() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.password_.ClearToEmpty();
}
inline const std::string& CheckUserRequest::password() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:hotelreservation.CheckUserRequest.password)
  return _internal_password();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CheckUserRequest::set_password(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.password_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:hotelreservation.CheckUserRequest.password)
}
inline std::string* CheckUserRequest::mutable_password() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:hotelreservation.CheckUserRequest.password)
  return _s;
}
inline const std::string& CheckUserRequest::_internal_password() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.password_.Get();
}
inline void CheckUserRequest::_internal_set_password(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.password_.Set(value, GetArena());
}
inline std::string* CheckUserRequest::_internal_mutable_password() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.password_.Mutable( GetArena());
}
inline std::string* CheckUserRequest::release_password() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:hotelreservation.CheckUserRequest.password)
  return _impl_.password_.Release();
}
inline void CheckUserRequest::set_allocated_password(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.password_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.password_.IsDefault()) {
          _impl_.password_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hotelreservation.CheckUserRequest.password)
}

// -------------------------------------------------------------------

// CheckUserResponse

// bool exists = 1;
inline void CheckUserResponse::clear_exists() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.exists_ = false;
}
inline bool CheckUserResponse::exists() const {
  // @@protoc_insertion_point(field_get:hotelreservation.CheckUserResponse.exists)
  return _internal_exists();
}
inline void CheckUserResponse::set_exists(bool value) {
  _internal_set_exists(value);
  // @@protoc_insertion_point(field_set:hotelreservation.CheckUserResponse.exists)
}
inline bool CheckUserResponse::_internal_exists() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.exists_;
}
inline void CheckUserResponse::_internal_set_exists(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.exists_ = value;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace hotelreservation


// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_hotel_5freservation_2eproto_2epb_2eh
